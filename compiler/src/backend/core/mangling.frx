import "std/libc.frx";
export import "../../frontend/core/namespace.frx";
export import "../../frontend/core/scope.frx";

extern
{
    i32 sprintf(mut char* str, char* format, ...);
}

mut char* buffer = nullptr;
mut usize buffer_size = 0;

void realloc_buffer(usize size)
{
    buffer_size = size;
    buffer = libc::realloc(buffer, buffer_size * frx::sizeof(char));
}

void mangle_namespace(Namespace* ns)
{
    if(ns == nullptr)
    {
        return;
    }

    mangle_namespace(ns->parent);

    if(libc::strcmp(ns->name, "") != 0)
    {
        usize size = libc::strlen(buffer) + libc::strlen(ns->name) + libc::strlen("_");
        if(size > buffer_size)
        {
            realloc_buffer(size);
        }

        libc::strcat(buffer, ns->name);
        libc::strcat(buffer, "_");
    }
}

export char* mangle_enum_name(Scope* scope, Namespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc::strlen(name);

    mut Namespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc::strlen(ns->name) + 1;

        temp = temp->parent;
    }

    if(size > buffer_size)
    {
        realloc_buffer(size);
    }

    libc::strcpy(buffer, "");

    mangle_namespace(ns);

    libc::strcat(buffer, name);

    char* buffer_end = libc::strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc::strcat(buffer, "E");

    return buffer;
}

export char* mangle_struct_name(Scope* scope, Namespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc::strlen(name);

    mut Namespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc::strlen(ns->name) + 1;

        temp = temp->parent;
    }

    if(size > buffer_size)
    {
        realloc_buffer(size);
    }

    libc::strcpy(buffer, "");

    mangle_namespace(ns);

    libc::strcat(buffer, name);

    char* buffer_end = libc::strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc::strcat(buffer, "S");

    return buffer;
}

export char* mangle_function_name(Scope* scope, Namespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc::strlen(name);

    if(namespace_is_global(ns) && libc::strcmp(name, "main") == 0)
    {
        if(size > buffer_size)
        {
            realloc_buffer(size);
        }

        libc::strcpy(buffer, name);

        return buffer;
    }

    mut Namespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc::strlen(ns->name) + 1;

        temp = temp->parent;
    }

    if(size > buffer_size)
    {
        realloc_buffer(size);
    }

    if(namespace_is_global(ns) && libc::strcmp(name, "main") == 0)
    {
        libc::strcpy(buffer, "main");
        return buffer;
    }

    libc::strcpy(buffer, "");

    mangle_namespace(ns);

    libc::strcat(buffer, name);

    char* buffer_end = libc::strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc::strcat(buffer, "F");

    return buffer;
}

export char* mangle_global_var_name(Scope* scope, Namespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc::strlen(name);

    mut Namespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc::strlen(ns->name) + 1;

        temp = temp->parent;
    }

    if(size > buffer_size)
    {
        realloc_buffer(size);
    }

    libc::strcpy(buffer, "");

    mangle_namespace(ns);

    libc::strcat(buffer, name);

    char* buffer_end = libc::strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc::strcat(buffer, "V");

    return buffer;
}
