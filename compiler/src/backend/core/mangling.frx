import "std/libc.frx";
export import "../../frontend/core/namespace.frx";
export import "../../frontend/core/scope.frx";

extern
{
    i32 sprintf(mut char* str, char* format, ...);
}

mut char* buffer = nullptr;
mut usize buffer_size = 0;

void validate_buffer_size(mut usize size)
{
    //This should ensure that the buffer is always big enough.
    //This whole file will be replaced eventually anyways, since it's not safe for multithreading.
    size = size * 2;

    if(buffer_size >= size)
    {
        return;
    }

    buffer_size = size;
    buffer = libc_realloc(buffer, buffer_size * frx::sizeof(char));
}

void mangle_namespace(CoreNamespace* ns)
{
    if(ns == nullptr)
    {
        return;
    }

    mangle_namespace(ns->parent);

    if(libc_strcmp(ns->name, "") != 0)
    {
        usize size = libc_strlen(buffer) + libc_strlen(ns->name) + libc_strlen("_");
        validate_buffer_size(size);

        libc_strcat(buffer, ns->name);
        libc_strcat(buffer, "_");
    }
}

export char* mangle_enum_name(CoreScope* scope, CoreNamespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc_strlen(name);

    mut CoreNamespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc_strlen(ns->name) + 1;

        temp = temp->parent;
    }

    validate_buffer_size(size);

    libc_strcpy(buffer, "");

    mangle_namespace(ns);

    libc_strcat(buffer, name);

    char* buffer_end = libc_strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc_strcat(buffer, "E");

    return buffer;
}

export char* mangle_struct_name(CoreScope* scope, CoreNamespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc_strlen(name);

    mut CoreNamespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc_strlen(ns->name) + 1;

        temp = temp->parent;
    }

    validate_buffer_size(size);

    libc_strcpy(buffer, "");

    mangle_namespace(ns);

    libc_strcat(buffer, name);

    char* buffer_end = libc_strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc_strcat(buffer, "S");

    return buffer;
}

export char* mangle_function_name(CoreScope* scope, CoreNamespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc_strlen(name);

    if(namespace_is_global(ns) && libc_strcmp(name, "main") == 0)
    {
        validate_buffer_size(size);

        libc_strcpy(buffer, name);

        return buffer;
    }

    mut CoreNamespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc_strlen(ns->name) + 1;

        temp = temp->parent;
    }

    validate_buffer_size(size);

    if(namespace_is_global(ns) && libc_strcmp(name, "main") == 0)
    {
        libc_strcpy(buffer, "main");
        return buffer;
    }

    libc_strcpy(buffer, "");

    mangle_namespace(ns);

    libc_strcat(buffer, name);

    char* buffer_end = libc_strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc_strcat(buffer, "F");

    return buffer;
}

export char* mangle_global_var_name(CoreScope* scope, CoreNamespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc_strlen(name);

    mut CoreNamespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc_strlen(ns->name) + 1;

        temp = temp->parent;
    }

    validate_buffer_size(size);

    libc_strcpy(buffer, "");

    mangle_namespace(ns);

    libc_strcat(buffer, name);

    char* buffer_end = libc_strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc_strcat(buffer, "V");

    return buffer;
}
