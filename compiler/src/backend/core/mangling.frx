import "std/libc.frx";
export import "../../frontend/core/namespace.frx";
export import "../../frontend/core/scope.frx";

extern
{
    i32 sprintf(mut char* str, char* format, ...);
}

mut char* buffer = nullptr;
mut usize buffer_size = 0;

void validate_buffer_size(mut usize size)
{
    //This should ensure that the buffer is always big enough.
    //This whole file will be replaced eventually anyways, since it's not safe for multithreading.
    size = size * 2;

    if(buffer_size >= size)
    {
        return;
    }

    buffer_size = size;
    buffer = libc::realloc(buffer, buffer_size * frx::sizeof(char));
}

void mangle_namespace(core::Namespace* ns)
{
    if(ns == nullptr)
    {
        return;
    }

    mangle_namespace(ns->parent);

    if(libc::strcmp(ns->name, "") != 0)
    {
        usize size = libc::strlen(buffer) + libc::strlen(ns->name) + libc::strlen("_");
        validate_buffer_size(size);

        libc::strcat(buffer, ns->name);
        libc::strcat(buffer, "_");
    }
}

export char* mangle_enum_name(core::Scope* scope, core::Namespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc::strlen(name);

    mut core::Namespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc::strlen(ns->name) + 1;

        temp = temp->parent;
    }

    validate_buffer_size(size);

    libc::strcpy(buffer, "");

    mangle_namespace(ns);

    libc::strcat(buffer, name);

    char* buffer_end = libc::strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc::strcat(buffer, "E");

    return buffer;
}

export char* mangle_struct_name(core::Scope* scope, core::Namespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc::strlen(name);

    mut core::Namespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc::strlen(ns->name) + 1;

        temp = temp->parent;
    }

    validate_buffer_size(size);

    libc::strcpy(buffer, "");

    mangle_namespace(ns);

    libc::strcat(buffer, name);

    char* buffer_end = libc::strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc::strcat(buffer, "S");

    return buffer;
}

export char* mangle_function_name(core::Scope* scope, core::Namespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc::strlen(name);

    if(namespace_is_global(ns) && libc::strcmp(name, "main") == 0)
    {
        validate_buffer_size(size);

        libc::strcpy(buffer, name);

        return buffer;
    }

    mut core::Namespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc::strlen(ns->name) + 1;

        temp = temp->parent;
    }

    validate_buffer_size(size);

    if(namespace_is_global(ns) && libc::strcmp(name, "main") == 0)
    {
        libc::strcpy(buffer, "main");
        return buffer;
    }

    libc::strcpy(buffer, "");

    mangle_namespace(ns);

    libc::strcat(buffer, name);

    char* buffer_end = libc::strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc::strcat(buffer, "F");

    return buffer;
}

export char* mangle_global_var_name(core::Scope* scope, core::Namespace* ns, char* name)
{
    frx::assert(scope != nullptr);

    frx::assert(name != nullptr);

    mut usize size = libc::strlen(name);

    mut core::Namespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc::strlen(ns->name) + 1;

        temp = temp->parent;
    }

    validate_buffer_size(size);

    libc::strcpy(buffer, "");

    mangle_namespace(ns);

    libc::strcat(buffer, name);

    char* buffer_end = libc::strrchr(buffer, '\0');
    sprintf(buffer_end, "%zu", scope->id);

    libc::strcat(buffer, "V");

    return buffer;
}
