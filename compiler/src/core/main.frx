import "std/libc.frx";
import "config.frx";
import "options.frx";
import "queue.frx";
import "../backend/backend.frx";
import "../frontend/ast/program.frx";
import "module.frx";

extern struct FILE;

extern
{
    char* realpath(char* filename, mut char* resolved_name);
    i32 printf(char* format, ...);
}

mut Program* program;
mut b8 failed = false;

mut List root_modules;

mut Queue syntax_queue;
mut Queue resolve_symbols_queue;
mut Queue semantic_queue;

export void module_compile(mut Module* module)
{
    frx::assert(module != nullptr);

    if(module->compiled)
    {
        return;
    }

    mut usize i;
    for(i = 0; i < list_size(&module->parsers); ++i)
    {
        Parser* parser = list_get(&module->parsers, i);
        queue_enqueue(&syntax_queue, parser);
    }

    module->compiled = true;
}

export Module* module_find_by_absolute_module_path(ModulePath* module_path)
{
    frx::assert(module_path != nullptr);

    mut usize i;
    for(i = 0; i < list_size(&root_modules); ++i)
    {
        Module* root_module = list_get(&root_modules, i);

        if(libc_strcmp(root_module->name, module_path->name) != 0)
        {
            continue;
        }

        Module* found_module = module_find_submodule(root_module, module_path->next);
        if(found_module != nullptr)
        {
            return found_module;
        }
    }

    return nullptr;
}

i32 main(usize argc, char** argv)
{
    config_init();
    lexer_init_keyword_table();

    list_init(&root_modules);

    queue_init(&syntax_queue);
    queue_init(&resolve_symbols_queue);
    queue_init(&semantic_queue);

    program = program_new();

    mut Option options[7];

    //TODO: Remove tmp
    mut Option tmp;
    tmp = (options[0] = create_option(OptionID::HELP, OptionType::OPT_ARG, 'h', "help"));
    tmp = (options[1] = create_option(OptionID::OUTPUT, OptionType::REQ_ARG, 'o', "output"));
    tmp = (options[2] = create_long_option(OptionID::TARGET, OptionType::REQ_ARG, "target"));
    tmp = (options[3] = create_long_option(OptionID::EMIT_AST, OptionType::NO_ARG, "emit-ast"));
    tmp = (options[4] = create_short_option(OptionID::LINK, OptionType::REQ_ARG, 'l'));
    tmp = (options[5] = create_option(OptionID::NONE, OptionType::NO_ARG, '\0', nullptr));
    tmp = (options[6] = create_long_option(OptionID::LIBRARY_PATH, OptionType::REQ_ARG, "library-path"));

    mut b8 emit_ast = false;

    mut Config* config = get_config();

    mut OptionID opt;
    while((opt = parse_command_line(argc, argv, options)) != 0)
    {
        switch(opt)
        {
            case OptionID::OUTPUT:
            {
                config->output = get_arg();
                break;
            }
            case OptionID::EMIT_AST:
            {
                emit_ast = true;
                break;
            }
            case OptionID::LINK:
            {
                list_push(&config->link_targets, get_arg());
                break;
            }
            case OptionID::LIBRARY_PATH:
            {
                config->library_path = get_arg();
                break;
            }
        }
    }

    mut Module* std_module = module_init("/usr/local/lib/furox/stdlib");
    libc_strcpy(std_module->name, "std");
    module_scan(std_module);
    list_push(&root_modules, std_module);

    mut usize i;
    for(i = 0; i < get_positional_argc(); i = i + 1)
    {
        char* arg = argv[i + 1];
        char fullpath[4096];
        realpath(arg, fullpath);

        mut Module* root_module = module_init(fullpath);
        libc_strcat(fullpath, "/src");
        root_module->filepath = libc_strdup(fullpath);

        module_scan(root_module);
        printf("Loaded root module: %s\n", root_module->name);
        list_push(&root_modules, root_module);
    }

    Module* prj_root_module = list_get(&root_modules, 1);
    module_compile(prj_root_module);

    while(!queue_is_empty(&syntax_queue))
    {
        Parser* parser = queue_dequeue(&syntax_queue);
        parser_parse(parser);
        queue_enqueue(&resolve_symbols_queue, parser);
    }

    while(!queue_is_empty(&resolve_symbols_queue))
    {
        Parser* parser = queue_dequeue(&resolve_symbols_queue);
        parser_resolve_symbols(parser);
        queue_enqueue(&semantic_queue, parser);
    }

    while(!queue_is_empty(&semantic_queue))
    {
        Parser* parser = queue_dequeue(&semantic_queue);
        parser_analyze(parser);
        failed = failed || parser->failed;
        list_push(&program->translation_units, parser->translation_unit);
    }

    if(emit_ast)
    {
        FILE* file = libc_fopen("frx.ast", "w");
        if(file != nullptr)
        {
            program_print(program, file, 0);
            libc_fclose(file);
        }
    }

    if(!failed)
    {
        return backend_generate_code(BackendType::NATIVE, program);
    }

    return failed;
}
