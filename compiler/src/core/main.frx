import "options.frx";
import "parser_table.frx";
import "queue.frx";
import "../backend/backend.frx";
import "../frontend/syntax/program.frx";

ASTProgram* program;
b8 failed = false;

Queue syntax_queue;
Queue resolve_imports_queue;
Queue semantic_queue;

void compile(char* filepath)
{
    if(parser_table_find(filepath) != nullptr)
    {
        return;
    }

    if(!parser_table_insert(filepath))
    {
        return;
    }

    Parser* parser = parser_table_find(filepath);

    assert(parser != nullptr);

    queue_enqueue(&syntax_queue, parser);
}

enum OptionID : u8
{
    NONE,
    POS_ARG,
    HELP,
    OUTPUT,
    TARGET,
    EMIT_AST
}

usize Main(usize argc, char** argv)
{
    lexer_init_keyword_table();

    queue_init(&syntax_queue);
    queue_init(&resolve_imports_queue);
    queue_init(&semantic_queue);

    program = make_program();

    Option[5] options;

    //TODO: Remove tmp
    Option tmp;
    tmp = options[0] = create_option(HELP, OPT_ARG, 'h', "help");
    tmp = options[1] = create_option(OUTPUT, REQ_ARG, 'o', "output");
    tmp = options[2] = create_long_option(TARGET, REQ_ARG, "target");
    tmp = options[3] = create_long_option(EMIT_AST, NO_ARG, "emit-ast");
    tmp = options[4] = create_option(NONE, NO_ARG, '\0', nullptr);

    b8 emit_ast = false;

    OptionID opt;
    while((opt = parse_command_line(argc, argv, options)) != 0)
    {
        switch(opt)
        {
            case EMIT_AST:
            {
                emit_ast = true;
                break;
            }
        }
    }

    usize i;
    for(i = 0; i < get_positional_argc(); i = i + 1)
    {
        char* arg = argv[i + 1];
        char[4096] fullpath;
        realpath(arg, fullpath);
        compile(fullpath);
    }

    while(!queue_is_empty(&syntax_queue))
    {
        Parser* parser = queue_dequeue(&syntax_queue);
        parser_parse(parser);
        queue_enqueue(&resolve_imports_queue, parser);
    }

    while(!queue_is_empty(&resolve_imports_queue))
    {
        Parser* parser = queue_dequeue(&resolve_imports_queue);
        parser_resolve_imports(parser);
        queue_enqueue(&semantic_queue, parser);
    }

    while(!queue_is_empty(&semantic_queue))
    {
        Parser* parser = queue_dequeue(&semantic_queue);
        parser_analyze(parser);
        failed = failed || parser->failed;
        list_push(&program->translation_units, parser->translation_unit);
    }

    if(emit_ast)
    {
        FILE* file = fopen("frx.ast", "w");
        if(file != nullptr)
        {
            print_program(program, file, 0);
            fclose(file);
        }
    }

    if(!failed)
    {
        backend_generate_code(BACKEND_TYPE_NATIVE, program, "output.c");
    }

    return failed;
}
