struct ShortOption
{
    Option* option;
}

struct LongOption
{
    char* name;

    Option* option;
}

export enum OptionType : u8
{
    OPTION_TYPE_NO_ARG,
    OPTION_TYPE_OPT_ARG,
    OPTION_TYPE_REQ_ARG
}

export struct Option
{
    OptionType type;

    char* arg;
}

macro SHORT_OPTIONS_COUNT = 0xFF;
macro LONG_OPTIONS_COUNT = 16;

struct Config
{
    ShortOption[SHORT_OPTIONS_COUNT] short_options;
    LongOption[LONG_OPTIONS_COUNT] long_options;

    Option[SHORT_OPTIONS_COUNT + LONG_OPTIONS_COUNT] options;

    usize next_free_option_index;
}

Config config;

export b8 is_option(char* arg)
{
    return arg[0] == '-';
}

b8 is_long_option(char* option)
{
    assert(option[0] != '\0');

    return option[1] == '-';
}

export void parse_command_line(usize argc, char** argv)
{
    usize i;
    for(i = 1; i < argc; i = i + 1)
    {
        char* option_name = argv[i];
        if(!is_option(option_name))
        {
            continue;
        }

        if(is_long_option(option_name))
        {
            option_name = option_name + 2;

            char* long_name = option_name;

            char* equals = strchr(option_name, '=');
            if(equals != nullptr)
            {
                //equals[0] = '\0';
                char temp = equals[0] = '\0';
            }

            Option* option = find_long_option(option_name);
            if(option == nullptr)
            {
                printf("%s: unrecognized command-line option --%s\n", argv[0], long_name);
                continue;
            }

            switch(option->type)
            {
                case OPTION_TYPE_NO_ARG:
                {
                    option->arg = "";
                    break;
                }
                case OPTION_TYPE_OPT_ARG:
                {
                    if(equals != nullptr)
                    {
                        if(equals[1] != '\0')
                        {
                            option->arg = equals + 1;
                        }
                        else
                        {
                            printf("%s: --%s specified without requiered argument!\n", argv[0], option_name);
                            exit(1);
                        }
                    }

                    break;
                }
                case OPTION_TYPE_REQ_ARG:
                {
                    if(equals != nullptr)
                    {
                        if(equals[1] != '\0')
                        {
                            option->arg = equals + 1;
                        }
                        else
                        {
                            printf("%s: --%s specified without requiered argument!\n", argv[0], option_name);
                            exit(1);
                        }
                    }
                    else
                    {
                        if(i < argc - 1)
                        {
                            option->arg = argv[i + 1];
                            i = i + 1;
                        }
                        else
                        {
                            printf("%s: --%s specified without requiered argument!\n", argv[0], option_name);
                            exit(1);
                        }
                    }

                    break;
                }
            }
        }
        else
        {
            option_name = option_name + 1;

            b8 finished_parsing = false;
            while(option_name[0] != '\0' && !finished_parsing)
            {
                char short_name = option_name[0];

                Option* option = find_short_option(short_name);
                if(option == nullptr)
                {
                    printf("%s: unrecognized command-line option -%c\n", argv[0], short_name);
                    option_name = option_name + 1;
                    continue;
                }

                switch(option->type)
                {
                    case OPTION_TYPE_NO_ARG:
                    {
                        option->arg = "";
                        option_name = option_name + 1;

                        break;
                    }
                    case OPTION_TYPE_OPT_ARG:
                    {
                        if(option_name[1] != '\0')
                        {
                            option->arg = option_name + 1;
                            finished_parsing = true;
                        }

                        break;
                    }
                    case OPTION_TYPE_REQ_ARG:
                    {
                        if(option_name[1] != '\0')
                        {
                            option->arg = option_name + 1;
                        }
                        else if(i == argc - 1)
                        {
                            printf("%s: -%c specified without requiered argument!\n", argv[0], short_name);
                            exit(1);
                        }
                        else
                        {
                            option->arg = argv[i + 1];
                            i = i + 1;
                        }

                        finished_parsing = true;

                        break;
                    }
                    default:
                    {
                        //Unreachable
                        assert(false);
                    }
                }
            }
        }
    }
}

export Option* find_short_option(char name)
{
    return config.short_options[name].option;
}

export Option* find_long_option(char* name)
{
    u64 index = hash_djb2(name) % LONG_OPTIONS_COUNT;
    LongOption* long_option = &config.long_options[index];

    if(strcmp(long_option->name, name) != 0)
    {
        return nullptr;
    }

    return long_option->option;
}

export Option* register_option(char short_name, char* long_name, OptionType type)
{
    Option* option = &config.options[config.next_free_option_index];
    config.next_free_option_index = config.next_free_option_index + 1;

    if(short_name != '\0')
    {
        ShortOption* short_option = &config.short_options[short_name];
        short_option->option = option;
    }

    if(long_name != nullptr)
    {
        u64 index = hash_djb2(long_name) % LONG_OPTIONS_COUNT;
        LongOption* long_option = &config.long_options[index];
        long_option->name = long_name;
        long_option->option = option;
    }

    option->type = type;

    return option;
}

export void options_debug_print()
{
    char c;
    for(c = 0; c < SHORT_OPTIONS_COUNT; c = c + 1)
    {
        Option* option = config.short_options[c].option;

        if(option == nullptr)
        {
            continue;
        }

        printf("Short option: '%c', arg: %s\n", c, option->arg);
    }

    usize i;
    for(i = 0; i < LONG_OPTIONS_COUNT; i = i + 1)
    {
        Option* option = config.long_options[i].option;
        char* name = config.long_options[i].name;

        if(option == nullptr)
        {
            continue;
        }

        printf("Long option: %s, arg: %s\n", name, option->arg);
    }
}
