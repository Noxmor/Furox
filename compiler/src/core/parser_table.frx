/*export*/ import "../frontend/core/parser.frx";

struct ParserTableEntry
{
    Parser* parser;
    ParserTableEntry* next;
}

macro PARSER_TABLE_CAPACITY = 1024;

struct ParserTable
{
    ParserTableEntry*[PARSER_TABLE_CAPACITY] entries;
}

ParserTable parser_table;

export Parser* parser_table_find(char* filepath)
{
    assert(filepath != nullptr);

    u64 index = hash_djb2(filepath) % PARSER_TABLE_CAPACITY;
    ParserTableEntry* entry = parser_table.entries[index];

    while(entry != nullptr)
    {
        Parser* parser = entry->parser;

        if(strcmp(parser_source_file(parser), filepath) == 0)
        {
            return parser;
        }

        entry = entry->next;
    }

    return nullptr;
}

b8 is_real_path(char* filepath)
{
    assert(filepath != nullptr);

    if(filepath[0] != '/')
    {
        return false;
    }

    while(filepath[0] != '\0')
    {
        if(strncmp(filepath, "/./",strlen("/./")) == 0
            || strncmp(filepath, "/../", strlen("/../")) == 0)
        {
            return false;
        }

        filepath = filepath + 1;
    }

    return true;
}

export b8 parser_table_insert(char* filepath)
{
    assert(is_real_path(filepath));

    u64 index = hash_djb2(filepath) % PARSER_TABLE_CAPACITY;
    ParserTableEntry* entry = parser_table.entries[index];

    while(entry != nullptr)
    {
        if(strcmp(parser_source_file(entry->parser), filepath) == 0)
        {
            return false;
        }

        entry = entry->next;
    }

    ParserTableEntry* new_entry = malloc(sizeof(ParserTableEntry));
    new_entry->parser = malloc(sizeof(Parser));
    parser_init(new_entry->parser, string_table_insert(filepath));
    new_entry->next = parser_table.entries[index];

    parser_table.entries[index] = new_entry;

    return true;
}
