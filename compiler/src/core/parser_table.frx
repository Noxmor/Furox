import "std/libc.frx";
import "hash.frx";
export import "../frontend/core/parser.frx";
import "../frontend/core/string_table.frx";

struct ParserTableEntry
{
    Parser* parser;
    ParserTableEntry* next;
}

enum Constants : u64
{
    PARSER_TABLE_CAPACITY = 1024
}

struct ParserTable
{
    ParserTableEntry* entries[Constants::PARSER_TABLE_CAPACITY];
}

mut ParserTable parser_table;

export Parser* parser_table_find(char* filepath)
{
    frx::assert(filepath != nullptr);

    u64 index = hash_djb2(filepath) % Constants::PARSER_TABLE_CAPACITY;
    mut ParserTableEntry* entry = parser_table.entries[index];

    while(entry != nullptr)
    {
        Parser* parser = entry->parser;

        if(libc::strcmp(Parser::source_file(parser), filepath) == 0)
        {
            return parser;
        }

        entry = entry->next;
    }

    return nullptr;
}

b8 is_real_path(mut char* filepath)
{
    frx::assert(filepath != nullptr);

    if(filepath[0] != '/')
    {
        return false;
    }

    while(filepath[0] != '\0')
    {
        if(libc::strncmp(filepath, "/./",libc::strlen("/./")) == 0
            || libc::strncmp(filepath, "/../", libc::strlen("/../")) == 0)
        {
            return false;
        }

        filepath = filepath + 1;
    }

    return true;
}

export b8 parser_table_insert(char* filepath)
{
    frx::assert(is_real_path(filepath));

    u64 index = hash_djb2(filepath) % Constants::PARSER_TABLE_CAPACITY;
    mut ParserTableEntry* entry = parser_table.entries[index];

    while(entry != nullptr)
    {
        if(libc::strcmp(Parser::source_file(entry->parser), filepath) == 0)
        {
            return false;
        }

        entry = entry->next;
    }

    mut ParserTableEntry* new_entry = libc::malloc(frx::sizeof(ParserTableEntry));
    new_entry->parser = libc::malloc(frx::sizeof(Parser));
    Parser::init(new_entry->parser, string_table_insert(filepath));
    new_entry->next = parser_table.entries[index];

    parser_table.entries[index] = new_entry;

    return true;
}
