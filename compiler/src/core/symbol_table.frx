import "std/libc.frx";
import "hash.frx";

export enum SymbolType : u8
{
    ENUM,
    STRUCT,
    FUNC,
    VAR
}

export struct Symbol
{
    SymbolType type;
    b8 exported;

    void* data;
}

Symbol* symbol_init(mut Symbol* symbol, SymbolType type, b8 exported, void* data)
{
    frx::assert(symbol != nullptr);

    frx::assert(data != nullptr);

    symbol->type = type;
    symbol->exported = exported;
    symbol->data = data;
}

enum Constants : u16
{
    SYMBOL_TABLE_CAPACITY = 1024
}

struct SymbolTableEntry
{
    char* name;
    Symbol symbol;
    SymbolTableEntry* next;
}

export struct SymbolTable
{
    SymbolTableEntry* entries[Constants::SYMBOL_TABLE_CAPACITY];
}

export Symbol* symbol_table_find(SymbolTable* table, SymbolType type, char* name)
{
    frx::assert(table != nullptr);

    frx::assert(name != nullptr);

    u64 index = hash_djb2(name) % Constants::SYMBOL_TABLE_CAPACITY;
    mut SymbolTableEntry* entry = table->entries[index];

    while(entry != nullptr)
    {
        Symbol* symbol = &entry->symbol;

        if(symbol->type == type && libc_strcmp(entry->name, name) == 0)
        {
            return symbol;
        }

        entry = entry->next;
    }

    return nullptr;
}

export void symbol_table_insert(SymbolTable* table, SymbolType type, char* name, b8 exported, void* data)
{
    frx::assert(table != nullptr);

    frx::assert(name != nullptr);

    frx::assert(data != nullptr);

    u64 index = hash_djb2(name) % Constants::SYMBOL_TABLE_CAPACITY;

    mut SymbolTableEntry* new_entry = libc_malloc(frx::sizeof(SymbolTableEntry));
    new_entry->name = name;
    symbol_init(&new_entry->symbol, type, exported, data);
    new_entry->next = table->entries[index];

    table->entries[index] = new_entry;
}
