import "../../core/arena.frx";
import "ast.frx";
import "expr.frx";
export import "../symbols/enum.frx";

extern struct FILE;

extern
{
    i32 fprintf(mut FILE* stream, char* format, ...);
}

namespace AST
{
    export struct EnumConstantDef
    {
        char* name;
        Expr* value;
    }

    namespace EnumConstantDef
    {
        export EnumConstantDef* new(Arena* arena, char* name, Expr* value)
        {
            frx::assert(name != nullptr);

            mut EnumConstantDef* constant = Arena::alloc(arena, frx::sizeof(EnumConstantDef));

            constant->name = name;
            constant->value = value;

            return constant;
        }
    }

    export struct EnumDef
    {
        SourceRange range;

        EnumSymbol symbol;

        b8 is_redefinition;
    }

    namespace EnumDef
    {
        export EnumDef* new(Arena* arena, core::Scope* scope, core::Namespace* ns,
            char* name, TokenType type, b8 exported)
        {
            mut EnumDef* enum_def = Arena::alloc(arena, frx::sizeof(EnumDef));

            enum_symbol_init(&enum_def->symbol, type, scope, ns, name, exported);

            enum_def->is_redefinition = false;

            return enum_def;
        }

        export void add_constant(Arena* arena, EnumDef* enum_def,
            mut EnumConstantDef* constant)
        {
            frx::assert(enum_def != nullptr);

            frx::assert(constant != nullptr);

            List* constants = &enum_def->symbol.constants;

            if(constant->value == nullptr)
            {
                mut Expr* new_value = nullptr;

                if(List::size(constants) == 0)
                {
                    IntLiteral* literal = AST::IntLiteral::new(arena, 0);
                    new_value = AST::Expr::from_int_literal(arena, literal);
                }
                else
                {
                    IntLiteral* literal = AST::IntLiteral::new(arena, 1);

                    EnumConstantDef* last_constant = List::get(constants,
                        List::size(constants) - 1);

                    Expr* left = last_constant->value;
                    Expr* right = AST::Expr::from_int_literal(arena, literal);

                    BinaryExpr* expr = AST::BinaryExpr::new(arena, TokenType::PLUS,
                        Operator::ADD, left, right);

                    new_value = AST::Expr::from_binary_expr(arena, expr);
                }

                constant->value = new_value;
            }

            List::push(constants, constant);
        }

        export void print(EnumDef* enum_def, mut FILE* file, usize depth)
        {
            frx::assert(enum_def != nullptr);

            frx::assert(file != nullptr);

            print_depth(file, depth);

            fprintf(file, "%s (%s)\n", "enum-definition", enum_def->symbol.name);

            mut usize i;
            for(i = 0; i < List::size(&enum_def->symbol.constants); i = i + 1)
            {
                EnumConstantDef* constant = List::get(&enum_def->symbol.constants, i);

                print_depth(file, depth + 1);
                fprintf(file, "%s\n", constant->name);
            }
        }
    }
}
