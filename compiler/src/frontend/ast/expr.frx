import "std/libc.frx";
import "../../core/arena.frx";
export import "error.frx";
export import "char_literal.frx";
export import "float_literal.frx";
export import "int_literal.frx";
export import "string_literal.frx";
export import "enum_constant.frx";
export import "func_call.frx";
export import "internal_func_call.frx";
export import "var.frx";
export import "struct_member.frx";
export import "unresolved_identifier.frx";
export import "initializer_list.frx";
export import "unary_expr.frx";
export import "binary_expr.frx";

extern struct FILE;

export enum ExprType : u8
{
    INVALID,
    ERROR,
    INT_LITERAL,
    FLOAT_LITERAL,
    CHAR_LITERAL,
    STRING_LITERAL,
    ENUM_CONSTANT,
    FUNC_CALL,
    INTERNAL_FUNC_CALL,
    VAR,
    STRUCT_MEMBER,
    UNRESOLVED_IDENTIFIER,
    INITIALIZER_LIST,
    UNARY_EXPR,
    BINARY_EXPR
}

export struct Expr
{
    ExprType type;

    Error* error;
    IntLiteral* int_literal;
    FloatLiteral* float_literal;
    CharLiteral* char_literal;
    StringLiteral* string_literal;
    EnumConstant* enum_constant;
    FuncCall* func_call;
    InternalFuncCall* internal_func_call;
    Var* var;
    StructMember* struct_member;
    UnresolvedIdentifier* unresolved_identifier;
    InitializerList* initializer_list;
    UnaryExpr* unary_expr;
    BinaryExpr* binary_expr;
}

Expr* expr_new(Arena* arena)
{
    mut Expr* expr = arena_alloc(arena, frx::sizeof(Expr));

    libc_memset(expr, 0, frx::sizeof(Expr));

    return expr;
}

export Expr* expr_from_error(Arena* arena, Error* error)
{
    frx::assert(error != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::ERROR;
    expr->error = error;

    return expr;
}

export Expr* expr_from_int_literal(Arena* arena, IntLiteral* literal)
{
    frx::assert(literal != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::INT_LITERAL;
    expr->int_literal = literal;

    return expr;
}

export Expr* expr_from_float_literal(Arena* arena, FloatLiteral* literal)
{
    frx::assert(literal != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::FLOAT_LITERAL;
    expr->float_literal = literal;

    return expr;
}

export Expr* expr_from_char_literal(Arena* arena, CharLiteral* literal)
{
    frx::assert(literal != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::CHAR_LITERAL;
    expr->char_literal = literal;

    return expr;
}

export Expr* expr_from_string_literal(Arena* arena, StringLiteral* literal)
{
    frx::assert(literal != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::STRING_LITERAL;
    expr->string_literal = literal;

    return expr;
}

export Expr* expr_from_enum_constant(Arena* arena, EnumConstant* enum_constant)
{
    frx::assert(enum_constant != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::ENUM_CONSTANT;
    expr->enum_constant = enum_constant;

    return expr;
}

export Expr* expr_from_func_call(Arena* arena, FuncCall* func_call)
{
    frx::assert(func_call != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::FUNC_CALL;
    expr->func_call = func_call;

    return expr;
}

export Expr* expr_from_internal_func_call(Arena* arena, InternalFuncCall* internal_func_call)
{
    frx::assert(internal_func_call != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::INTERNAL_FUNC_CALL;
    expr->internal_func_call = internal_func_call;

    return expr;
}

export Expr* expr_from_var(Arena* arena, Var* var)
{
    frx::assert(var != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::VAR;
    expr->var = var;

    return expr;
}

export Expr* expr_from_struct_member(Arena* arena, StructMember* struct_member)
{
    frx::assert(struct_member != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::STRUCT_MEMBER;
    expr->struct_member;

    return expr;
}

export Expr* expr_from_unresolved_identifier(Arena* arena, UnresolvedIdentifier* unresolved_identifier)
{
    frx::assert(unresolved_identifier != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::UNRESOLVED_IDENTIFIER;
    expr->unresolved_identifier = unresolved_identifier;

    return expr;
}

export Expr* expr_from_initializer_list(Arena* arena, InitializerList* initializer_list)
{
    frx::assert(initializer_list != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::INITIALIZER_LIST;
    expr->initializer_list = initializer_list;

    return expr;
}

export Expr* expr_from_unary_expr(Arena* arena, UnaryExpr* unary_expr)
{
    frx::assert(unary_expr != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::UNARY_EXPR;
    expr->unary_expr = unary_expr;

    return expr;
}

export Expr* expr_from_binary_expr(Arena* arena, BinaryExpr* binary_expr)
{
    frx::assert(binary_expr != nullptr);

    mut Expr* expr = expr_new(arena);

    expr->type = ExprType::BINARY_EXPR;
    expr->binary_expr = binary_expr;

    return expr;
}

export void expr_print(Expr* expr, mut FILE* file, usize depth)
{
    frx::assert(expr != nullptr);

    frx::assert(file != nullptr);

    switch(expr->type)
    {
        case ExprType::INT_LITERAL:
        {
            int_literal_print(expr->int_literal, file, depth);

            break;
        }

        case ExprType::FLOAT_LITERAL:
        {
            float_literal_print(expr->float_literal, file, depth);

            break;
        }

        case ExprType::CHAR_LITERAL:
        {
            char_literal_print(expr->char_literal, file, depth);

            break;
        }

        case ExprType::STRING_LITERAL:
        {
            string_literal_print(expr->string_literal, file, depth);

            break;
        }

        case ExprType::ENUM_CONSTANT:
        {
            enum_constant_print(expr->enum_constant, file, depth);

            break;
        }

        case ExprType::FUNC_CALL:
        {
            func_call_print(expr->func_call, file, depth);

            break;
        }

        case ExprType::INTERNAL_FUNC_CALL:
        {
            internal_func_call_print(expr->internal_func_call, file, depth);

            break;
        }

        case ExprType::VAR:
        {
            var_print(expr->var, file, depth);

            break;
        }

        case ExprType::STRUCT_MEMBER:
        {
            struct_member_print(expr->struct_member, file, depth);

            break;
        }

        case ExprType::UNRESOLVED_IDENTIFIER:
        {
            unresolved_identifier_print(expr->unresolved_identifier, file, depth);

            break;
        }

        case ExprType::INITIALIZER_LIST:
        {
            initializer_list_print(expr->initializer_list, file, depth);

            break;
        }

        case ExprType::UNARY_EXPR:
        {
            unary_expr_print(expr->unary_expr, file, depth);

            break;
        }

        case ExprType::BINARY_EXPR:
        {
            binary_expr_print(expr->binary_expr, file, depth);

            break;
        }

        default:
        {
            frx::assert(false);

            break;
        }
    }
}
