import "../../core/arena.frx";
import "ast.frx";
import "../core/source_range.frx";
import "func_params.frx";
import "scope.frx";
import "type_specifier.frx";
export import "../symbols/func.frx";

extern struct FILE;

extern
{
    i32 fprintf(mut FILE* stream, char* format, ...);
}

export struct FuncDef
{
    SourceRange range;

    TypeSpecifier* return_type;
    FuncSymbol symbol;
    FuncParams* params;
    Scope* body;

    b8 is_redefinition;
}

export FuncDef* func_def_new(Arena* arena, CoreScope* scope, CoreNamespace* ns,
        char* name, TypeSpecifier* return_type, b8 exported)
{
    frx::assert(return_type != nullptr);

    mut FuncDef* func_def = arena_alloc(arena, frx::sizeof(FuncDef));

    func_def->return_type = return_type;
    func_symbol_init(&func_def->symbol, scope, ns, name, exported, false);
    func_def->params = nullptr;
    func_def->body = nullptr;
    func_def->is_redefinition = false;

    return func_def;
}

export void func_def_print(FuncDef* func_def, mut FILE* file, usize depth)
{
    frx::assert(func_def != nullptr);

    frx::assert(file != nullptr);

    print_depth(file, depth);

    fprintf(file, "%s (%s)\n", "function-definition", func_def->symbol.name);

    type_specifier_print(func_def->return_type, file, depth + 1);
    func_params_print(func_def->params, file, depth + 1);
    scope_print(func_def->body, file, depth + 1);
}
