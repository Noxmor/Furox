import "std/libc.frx";
import "../../core/arena.frx";
export import "break_stmt.frx";
export import "continue_stmt.frx";
export import "return_stmt.frx";
export import "expr_stmt.frx";
export import "var_decl.frx";
export import "var_def.frx";
export import "if_stmt.frx";
export import "for_loop.frx";
export import "while_loop.frx";
export import "do_while_loop.frx";
export import "switch_stmt.frx";
export import "scope.frx";

extern struct FILE;

extern
{
    i32 fprintf(mut FILE* stream, char* format, ...);
}

export enum StmtType : u8
{
    INVALID,
    BREAK_STMT,
    CONTINUE_STMT,
    RETURN_STMT,
    EXPR_STMT,
    VAR_DECL,
    VAR_DEF,
    IF_STMT,
    FOR_LOOP,
    WHILE_LOOP,
    DO_WHILE_LOOP,
    SWITCH_STMT,
    SCOPE
}

export struct Stmt
{
    StmtType type;

    BreakStmt* break_stmt;
    ContinueStmt* continue_stmt;
    ReturnStmt* return_stmt;
    ExprStmt* expr_stmt;
    VarDecl* var_decl;
    VarDef* var_def;
    IfStmt* if_stmt;
    ForLoop* for_loop;
    WhileLoop* while_loop;
    DoWhileLoop* do_while_loop;
    SwitchStmt* switch_stmt;
    Scope* scope;
}

Stmt* stmt_new(Arena* arena)
{
    mut Stmt* stmt = arena_alloc(arena, frx::sizeof(Stmt));

    libc_memset(stmt, 0, frx::sizeof(Stmt));

    return stmt;
}

export Stmt* stmt_from_break_stmt(Arena* arena, BreakStmt* break_stmt)
{
    frx::assert(break_stmt != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::BREAK_STMT;
    stmt->break_stmt = break_stmt;

    return stmt;
}

export Stmt* stmt_from_continue_stmt(Arena* arena, ContinueStmt* continue_stmt)
{
    frx::assert(continue_stmt != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::CONTINUE_STMT;
    stmt->continue_stmt = continue_stmt;

    return stmt;
}

export Stmt* stmt_from_return_stmt(Arena* arena, ReturnStmt* return_stmt)
{
    frx::assert(return_stmt != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::RETURN_STMT;
    stmt->return_stmt = return_stmt;

    return stmt;
}

export Stmt* stmt_from_expr_stmt(Arena* arena, ExprStmt* expr_stmt)
{
    frx::assert(expr_stmt != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::EXPR_STMT;
    stmt->expr_stmt = expr_stmt;

    return stmt;
}

export Stmt* stmt_from_var_decl(Arena* arena, VarDecl* var_decl)
{
    frx::assert(var_decl != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::VAR_DECL;
    stmt->var_decl = var_decl;

    return stmt;
}

export Stmt* stmt_from_var_def(Arena* arena, VarDef* var_def)
{
    frx::assert(var_def != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::VAR_DEF;
    stmt->var_def = var_def;

    return stmt;
}

export Stmt* stmt_from_if_stmt(Arena* arena, IfStmt* if_stmt)
{
    frx::assert(if_stmt != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::IF_STMT;
    stmt->if_stmt = if_stmt;

    return stmt;
}

export Stmt* stmt_from_for_loop(Arena* arena, ForLoop* for_loop)
{
    frx::assert(for_loop != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::FOR_LOOP;
    stmt->for_loop = for_loop;

    return stmt;
}

export Stmt* stmt_from_while_loop(Arena* arena, WhileLoop* while_loop)
{
    frx::assert(while_loop != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::WHILE_LOOP;
    stmt->while_loop = while_loop;

    return stmt;
}

export Stmt* stmt_from_do_while_loop(Arena* arena, DoWhileLoop* do_while_loop)
{
    frx::assert(do_while_loop != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::DO_WHILE_LOOP;
    stmt->do_while_loop = do_while_loop;

    return stmt;
}

export Stmt* stmt_from_switch_stmt(Arena* arena, SwitchStmt* switch_stmt)
{
    frx::assert(switch_stmt != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::SWITCH_STMT;
    stmt->switch_stmt = switch_stmt;

    return stmt;
}

export Stmt* stmt_from_scope(Arena* arena, Scope* scope)
{
    frx::assert(scope != nullptr);

    mut Stmt* stmt = stmt_new(arena);

    stmt->type = StmtType::SCOPE;
    stmt->scope = scope;

    return stmt;
}

export void stmt_print(Stmt* stmt, mut FILE* file, usize depth)
{
    frx::assert(stmt != nullptr);

    frx::assert(file != nullptr);

    switch(stmt->type)
    {
        case StmtType::BREAK_STMT:
            {
                break_stmt_print(stmt->break_stmt, file, depth);

                break;
            }

        case StmtType::CONTINUE_STMT:
            {
                continue_stmt_print(stmt->continue_stmt, file, depth);

                break;
            }

        case StmtType::RETURN_STMT:
            {
                return_stmt_print(stmt->return_stmt, file, depth);

                break;
            }

        case StmtType::EXPR_STMT:
            {
                expr_stmt_print(stmt->expr_stmt, file, depth);

                break;
            }

        case StmtType::VAR_DECL:
            {
                var_decl_print(stmt->var_decl, file, depth);

                break;
            }

        case StmtType::VAR_DEF:
            {
                var_def_print(stmt->var_def, file, depth);

                break;
            }

        case StmtType::IF_STMT:
            {
                if_stmt_print(stmt->if_stmt, file, depth);

                break;
            }

        case StmtType::FOR_LOOP:
            {
                for_loop_print(stmt->for_loop, file, depth);

                break;
            }

        case StmtType::WHILE_LOOP:
            {
                while_loop_print(stmt->while_loop, file, depth);

                break;
            }

        case StmtType::DO_WHILE_LOOP:
            {
                do_while_loop_print(stmt->do_while_loop, file, depth);

                break;
            }

        case StmtType::SWITCH_STMT:
            {
                switch_stmt_print(stmt->switch_stmt, file, depth);

                break;
            }

        case StmtType::SCOPE:
            {
                scope_print(stmt->scope, file, depth);

                break;
            }

        default:
            {
                frx::assert(false);

                break;
            }
    }
}
