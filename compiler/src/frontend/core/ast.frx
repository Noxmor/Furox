char*[AST_TYPE_COUNT] ast_type_names = {
    "program",
    "compound",
    "type-specifier",
    "import-statement",
    "extern-block",
    "namespace",
    "enum-definition",
    "enum-constant",
    "struct-definition",
    "function-declaration",
    "function-definition",
    "parameter-list",
    "function-call",
    "scope",
    "global-variable-declaration",
    "global-variable-definition",
    "variable-declaration",
    "variable-definition",
    "variable",
    "enum-constant-or-global-var",
    "unary-expression",
    "binary-expression",
    "expression-statement",
    "break-statement",
    "continue-statement",
    "return-statement",
    "int-literal",
    "char-literal",
    "string-literal",
    "if-statement",
    "for-loop",
    "while-loop",
    "do-while-loop",
    "sizeof",
    "enum-count"
};

export enum ASTType : u8
{
    AST_TYPE_PROGRAM,
    AST_TYPE_COMPOUND,

    AST_TYPE_TYPE_SPECIFIER,

    AST_TYPE_IMPORT_STMT,
    AST_TYPE_EXTERN_BLOCK,
    AST_TYPE_NAMESPACE,
    AST_TYPE_ENUM_DEF,
    AST_TYPE_ENUM_CONSTANT,
    AST_TYPE_STRUCT_DEF,
    AST_TYPE_FUNC_DECL,
    AST_TYPE_FUNC_DEF,
    AST_TYPE_FUNC_PARAMS,
    AST_TYPE_FUNC_CALL,
    AST_TYPE_SCOPE,

    AST_TYPE_GLOBAL_VAR_DECL,
    AST_TYPE_GLOBAL_VAR_DEF,

    AST_TYPE_VAR_DECL,
    AST_TYPE_VAR_DEF,
    AST_TYPE_VAR,

    AST_TYPE_ENUM_CONSTANT_OR_GLOBAL_VAR,

    AST_TYPE_UNARY_EXPR,
    AST_TYPE_BINARY_EXPR,

    AST_TYPE_EXPR_STMT,

    AST_TYPE_BREAK_STMT,
    AST_TYPE_CONTINUE_STMT,
    AST_TYPE_RETURN_STMT,

    AST_TYPE_INT_LITERAL,
    AST_TYPE_CHAR_LITERAL,
    AST_TYPE_STRING_LITERAL,

    AST_TYPE_IF_STMT,
    AST_TYPE_FOR_LOOP,
    AST_TYPE_WHILE_LOOP,
    AST_TYPE_DO_WHILE_LOOP,

    AST_TYPE_SIZEOF,
    AST_TYPE_ENUM_COUNT,

    AST_TYPE_COUNT
}

export struct AST
{
    ASTType type;
    void* node;
}

export AST* make_ast(Arena* arena, ASTType type, void* node)
{
    assert(type < AST_TYPE_COUNT);

    assert(node != nullptr);

    AST* ast = arena_alloc(arena, sizeof(AST));

    ast->type = type;
    ast->node = node;

    return ast;
}

export void print_ast(AST* ast, FILE* file, usize depth)
{
    assert(ast != nullptr);

    void* node = ast->node;

    switch(ast->type)
    {
        case AST_TYPE_COMPOUND:
        {
            print_compound(node, file, depth);

            break;
        }
        case AST_TYPE_IMPORT_STMT:
        {
            print_import_stmt(node, file, depth);

            break;
        }
        case AST_TYPE_EXTERN_BLOCK:
        {
            print_extern_block(node, file, depth);

            break;
        }
        case AST_TYPE_NAMESPACE:
        {
            print_namespace(node, file, depth);

            break;
        }
        case AST_TYPE_ENUM_DEF:
        {
            print_enum_def(node, file, depth);

            break;
        }
        case AST_TYPE_ENUM_CONSTANT:
        {
            print_enum_constant(node, file, depth);

            break;
        }
        case AST_TYPE_STRUCT_DEF:
        {
            print_struct_def(node, file, depth);

            break;
        }
        case AST_TYPE_FUNC_DECL:
        {
            print_func_decl(node, file, depth);

            break;
        }
        case AST_TYPE_FUNC_DEF:
        {
            print_func_def(node, file, depth);

            break;
        }
        case AST_TYPE_FUNC_CALL:
        {
            print_func_call(node, file, depth);

            break;
        }
        case AST_TYPE_SCOPE:
        {
            print_scope(node, file, depth);

            break;
        }
        case AST_TYPE_GLOBAL_VAR_DECL:
        {
            print_global_var_decl(node, file, depth);

            break;
        }
        case AST_TYPE_GLOBAL_VAR_DEF:
        {
            print_global_var_def(node, file, depth);

            break;
        }
        case AST_TYPE_VAR_DECL:
        {
            print_var_decl(node, file, depth);

            break;
        }
        case AST_TYPE_VAR_DEF:
        {
            print_var_def(node, file, depth);

            break;
        }
        case AST_TYPE_VAR:
        {
            print_var(node, file, depth);

            break;
        }
        case AST_TYPE_ENUM_CONSTANT_OR_GLOBAL_VAR:
        {
            print_enum_constant_or_global_var(node, file, depth);

            break;
        }
        case AST_TYPE_UNARY_EXPR:
        {
            print_unary_expr(node, file, depth);

            break;
        }
        case AST_TYPE_BINARY_EXPR:
        {
            print_binary_expr(node, file, depth);

            break;
        }
        case AST_TYPE_EXPR_STMT:
        {
            print_expr_stmt(node, file, depth);

            break;
        }
        case AST_TYPE_BREAK_STMT:
        {
            print_break_stmt(node, file, depth);

            break;
        }
        case AST_TYPE_CONTINUE_STMT:
        {
            print_continue_stmt(node, file, depth);

            break;
        }
        case AST_TYPE_RETURN_STMT:
        {
            print_return_stmt(node, file, depth);

            break;
        }
        case AST_TYPE_INT_LITERAL:
        {
            print_int_literal(node, file, depth);

            break;
        }
        case AST_TYPE_CHAR_LITERAL:
        {
            print_char_literal(node, file, depth);

            break;
        }
        case AST_TYPE_STRING_LITERAL:
        {
            print_string_literal(node, file, depth);

            break;
        }
        case AST_TYPE_IF_STMT:
        {
            print_if_stmt(node, file, depth);

            break;
        }
        case AST_TYPE_FOR_LOOP:
        {
            print_for_loop(node, file, depth);

            break;
        }
        case AST_TYPE_WHILE_LOOP:
        {
            print_while_loop(node, file, depth);

            break;
        }
        case AST_TYPE_DO_WHILE_LOOP:
        {
            print_do_while_loop(node, file, depth);

            break;
        }
        case AST_TYPE_SIZEOF:
        {
            print_sizeof(node, file, depth);

            break;
        }
        case AST_TYPE_ENUM_COUNT:
        {
            print_enum_count(node, file, depth);

            break;
        }
        default:
        {
            assert(false);

            break;
        }
    }
}

export struct ASTCompound
{
    List nodes;
}

export ASTCompound* make_compound(Arena* arena)
{
    ASTCompound* compound = arena_alloc(arena, sizeof(ASTCompound));

    list_init(&compound->nodes);

    return compound;
}

export void print_compound(ASTCompound* compound, FILE* file, usize depth)
{
    assert(compound != nullptr);

    assert(file != nullptr);

    print_ast_depth(file, depth);

    fprintf(file, "%s\n", ast_type_to_str(AST_TYPE_COMPOUND));

    usize i;
    for(i = 0; i < list_size(&compound->nodes); i = i + 1)
    {
        AST* ast = list_get(&compound->nodes, i);
        print_ast(ast, file, depth + 1);
    }
}

export void print_ast_depth(FILE* file, usize depth)
{
    assert(file != nullptr);

    usize i;
    for(i = 0; i < depth; i = i + 1)
    {
        fprintf(file, "    ");
    }
}

export char* ast_type_to_str(ASTType type)
{
    assert(type < AST_TYPE_COUNT);

    return ast_type_names[type];
}
