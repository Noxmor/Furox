import "std/libc.frx";
import "namespace.frx";
import "token.frx";
import "../../core/log.frx";

export void error_import_stmt_invalid_filepath(char* filepath,
    SourceLocation loc, char* imported_filepath)
{
    log_error(filepath, loc, "Failed to import file %s!", imported_filepath);
}

export void error_enum_redefinition(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Encountered redefinition of enum %s!", name);
}

export void error_undefined_enum_constant(char* filepath, SourceLocation loc,
    char* enum_name, char* constant_name)
{
    log_error(filepath, loc, "Encountered undefined enum-constant %s for enum %s!",
        constant_name, enum_name);
}

export void error_ambiguous_unresolved_identifier(char* filepath,
    SourceLocation loc, mut CoreNamespace* ns, char* name)
{
    mut usize size = 1;

    mut CoreNamespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc_strlen(token_type_to_str(TokenType::NAMESPACE_RESOLUTION))
            + libc_strlen(temp->name);
        temp = temp->parent;
    }

    char ns_str[size];
    libc_strcpy(ns_str, "");

    while(ns != nullptr)
    {
        libc_strcat(ns_str, token_type_to_str(TokenType::NAMESPACE_RESOLUTION));
        libc_strcat(ns_str, ns->name);

        ns = ns->parent;
    }

    log_error(filepath, loc, "Encountered ambiguous %s %s%s!",
        "unresolved-identifier", ns_str, name);
}

export void error_namespace_is_reserved(char* filepath, SourceLocation loc,
    mut CoreNamespace* ns)
{
    mut usize size = 1 + libc_strlen(ns->name);

    mut CoreNamespace* temp = ns->parent;
    while(temp != nullptr)
    {
        size = size + libc_strlen(token_type_to_str(TokenType::NAMESPACE_RESOLUTION))
            + libc_strlen(temp->name);
        temp = temp->parent;
    }

    char ns_str[size];
    libc_strcpy(ns_str, ns->name);

    ns = ns->parent;

    while(ns != nullptr)
    {
        libc_strcat(ns_str, token_type_to_str(TokenType::NAMESPACE_RESOLUTION));
        libc_strcat(ns_str, ns->name);

        ns = ns->parent;
    }

    log_error(filepath, loc, "Invalid namespace, because namespace %s is reserved!",
        ns_str);
}

export void error_namespace_enum_conflict(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Definition of namespace %s is in conflict with definition of enum %s!",
        name, name);
}

export void error_struct_decl_redefinition(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Encountered redefinition of struct %s!", name);
}

export void error_struct_def_redefinition(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Encountered redefinition of struct %s!", name);
}

export void error_not_a_struct_member(char* filepath, SourceLocation loc)
{
    log_error(filepath, loc, "Not a struct member!");
}

export void error_undefined_type_specifier(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Encountered undefined type-specifier %s!", name);
}

export void error_undefined_func_call(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Encountered function-call to undefined function %s!",
        name);
}

export void error_func_decl_redefinition(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Encountered redefinition of function %s!", name);
}

export void error_func_def_redefinition(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Encountered redefinition of function %s!", name);
}

export void error_var_redefinition(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Encountered redefinition of variable %s!", name);
}

export void error_undefined_var(char* filepath, SourceLocation loc, char* name)
{
    log_error(filepath, loc, "Encountered undefined variable %s!", name);
}

export void error_assignment_const_var(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Invalid assignment of non-mutable variable %s!",
        name);
}

export void error_sizeof_invalid_arg(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Invalid argument %s to internal function sizeof!",
        name);
}

export void error_enum_count_invalid_arg(char* filepath, SourceLocation loc,
    char* name)
{
    log_error(filepath, loc, "Invalid argument %s to internal function enum_count!",
        name);
}

export void error_unresolved_identifier(char* filepath, SourceLocation loc,
    mut CoreNamespace* ns, char* name)
{
    mut usize size = 1;

    mut CoreNamespace* temp = ns;
    while(temp != nullptr)
    {
        size = size + libc_strlen(token_type_to_str(TokenType::NAMESPACE_RESOLUTION))
            + libc_strlen(temp->name);
        temp = temp->parent;
    }

    char ns_str[size];
    libc_strcpy(ns_str, "");

    while(ns != nullptr)
    {
        libc_strcat(ns_str, token_type_to_str(TokenType::NAMESPACE_RESOLUTION));
        libc_strcat(ns_str, ns->name);

        ns = ns->parent;
    }

    log_error(filepath, loc, "Could not resolve identifier %s%s%s!",
        ns_str, token_type_to_str(TokenType::NAMESPACE_RESOLUTION), name);
}
