import "std/libc.frx";

export struct CoreNamespace
{
    char* name;
    CoreNamespace* parent;
}

export CoreNamespace* namespace_create(CoreNamespace* parent, char* name)
{
    mut CoreNamespace* ns = libc_malloc(frx::sizeof(CoreNamespace));

    ns->name = name;
    ns->parent = parent;

    return ns;
}

export void namespace_destroy(CoreNamespace* ns)
{
    if(ns == nullptr)
    {
        return;
    }

    namespace_destroy(ns->parent);
    libc_free(ns);
}

export b8 namespace_is_subset_of(CoreNamespace* child, CoreNamespace* parent)
{
    if(child == nullptr)
    {
        return true;
    }

    if(parent == nullptr)
    {
        return false;
    }

    mut CoreNamespace* child_iter = child;
    mut CoreNamespace* parent_iter  = parent;

    while(child_iter != nullptr && parent_iter != nullptr)
    {
        if(libc_strcmp(child_iter->name, parent_iter->name) != 0)
        {
            return false;
        }

        child_iter = child_iter->parent;
        parent_iter = parent_iter->parent;
    }

    return child_iter == nullptr;
}

export b8 namespace_equals(CoreNamespace* left, CoreNamespace* right)
{
    if(left == nullptr && right == nullptr)
    {
        return true;
    }

    if(left == nullptr && right != nullptr)
    {
        return false;
    }

    if(left != nullptr && right == nullptr)
    {
        return false;
    }

    if(libc_strcmp(left->name, right->name) != 0)
    {
        return false;
    }

    return namespace_equals(left->parent, right->parent);
}

export b8 namespace_is_global(CoreNamespace* ns)
{
    return ns == nullptr;
}

export b8 namespace_is_internal(CoreNamespace* ns)
{
    return ns != nullptr && libc_strcmp(ns->name, "frx") == 0
        && namespace_is_global(ns->parent);
}
