export struct Parser
{
    Lexer lexer;

    ASTCompound* translation_unit;

    Token* token;

    Namespace* current_namespace;
    Scope* current_scope;

    List imported_parsers;

    b8 panic;
    b8 failed;

    Arena arena;

    EnumTable enum_table;
    StructTable struct_table;
    FuncTable func_table;
    VarTable var_table;
}

export void parser_init(Parser* parser, char* filepath)
{
    assert(parser != nullptr);

    assert(filepath != nullptr);

    lexer_init(&parser->lexer, filepath);

    parser->translation_unit = nullptr;

    parser->token = lexer_peek(&parser->lexer, 0);

    parser->current_namespace = namespace_create_global();
    parser->current_scope = scope_create(nullptr);

    list_init(&parser->imported_parsers);

    parser->panic = false;
    parser->failed = false;

    arena_init(&parser->arena, 1024 * 1024);

    enum_table_init(&parser->enum_table);
    struct_table_init(&parser->struct_table);
    func_table_init(&parser->func_table);
    var_table_init(&parser->var_table);
}

void parser_advance(Parser* parser)
{
    assert(parser != nullptr);

    lexer_next_token(&parser->lexer);
}

export void parser_eat(Parser* parser, TokenType type)
{
    if(parser->token->type != type)
    {
        if(!parser->panic)
        {   printf("%s:%zu%zu: Error: expected '%s', but found '%s'\n",
                parser->lexer.filepath, parser->token->range.start.line,
                parser->token->range.start.column, token_type_to_str(type),
                token_type_to_str(parser->token->type));
        }

        parser->failed = true;
        return;
    }

    parser->panic = false;
    parser_advance(parser);
}

void parser_panic(Parser* parser)
{
    assert(parser != nullptr);

    parser->panic = true;

    while(true)
    {
        switch(parser->token->type)
        {
            case TOKEN_TYPE_EOF:
            {

            }
            case TOKEN_TYPE_ERROR:
            {

            }
            case TOKEN_TYPE_SEMICOLON:
            {

            }
            case TOKEN_TYPE_RBRACE:
            {
                return;
            }
            default:
            {
                parser_advance(parser);

                break;
            }
        }
    }
}

export void parser_parse(Parser* parser)
{
    assert(parser != nullptr);

    parser->translation_unit = parse_translation_unit(parser);
}

export void parser_analyze(Parser* parser)
{
    assert(parser != nullptr);

    analyze_compound(parser, parser->translation_unit);
}

export void parser_next_token(Parser* parser)
{
    lexer_next_token(&parser->lexer);
}

export Token* parser_peek(Parser* parser, usize offset)
{
    assert(parser != nullptr);

    return lexer_peek(&parser->lexer, offset);
}

export void parser_add_imported_parser(Parser* parser, Parser* imported_parser)
{
    assert(parser != nullptr);

    assert(imported_parser != nullptr);

    list_push(&parser->imported_parsers, imported_parser);
}

export EnumSymbol* parser_find_enum_symbol_r(Parser* parser, Namespace* ns,
    char* name)
{
    EnumSymbol* symbol = parser_find_enum_symbol(parser, ns, name);
    while(symbol == nullptr && ns != nullptr)
    {
        ns = ns->parent;
        symbol = parser_find_enum_symbol(parser, ns, name);
    }

    return symbol;
}

export EnumSymbol* parser_find_enum_symbol(Parser* parser, Namespace* ns,
    char* name)
{
    assert(parser != nullptr);

    EnumSymbol* symbol = enum_table_find(&parser->enum_table, ns, name);
    if(symbol != nullptr)
    {
        return symbol;
    }

    usize i;
    for(i = 0; i < list_size(&parser->imported_parsers); i = i + 1)
    {
        Parser* imported_parser = list_get(&parser->imported_parsers, i);

        symbol = enum_table_find(&imported_parser->enum_table, ns, name);
        if(symbol != nullptr && symbol->exported)
        {
            return symbol;
        }
    }

    return nullptr;
}

export char* parser_source_file(Parser* parser)
{
    assert(parser != nullptr);

    return lexer_source_file(&parser->lexer);
}

export void parser_destroy(Parser* parser)
{
    assert(parser != nullptr);

    lexer_destroy(&parser->lexer);
}

void parser_push_namespace(Parser* parser, char* name)
{
    assert(parser != nullptr);

    parser->current_namespace = namespace_create(parser->current_namespace,
        name);
}

void parser_pop_namespace(Parser* parser)
{
    assert(parser != nullptr);

    assert(parser->current_namespace != nullptr);

    parser->current_namespace = parser->current_namespace->parent;
}

void parser_push_scope(Parser* parser)
{
    assert(parser != nullptr);

    parser->current_scope = scope_create(parser->current_scope);
}

void parser_pop_scope(Parser* parser)
{
    assert(parser != nullptr);

    parser->current_scope = parser->current_scope->parent;
}
