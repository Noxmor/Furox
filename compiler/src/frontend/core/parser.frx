import "std/libc.frx";
export import "lexer.frx";
import "namespace.frx";
import "scope.frx";
import "../ast/compound.frx";
import "../sema/global_scope.frx";
import "../resolution/global_scope.frx";
import "../syntax/translation_unit.frx";
import "../symbols/var.frx";
export import "../../core/arena.frx";
import "../../core/list.frx";
import "../../core/log.frx";
import "../../core/main.frx";
import "../../core/module.frx";
import "../../core/symbol_table.frx";

extern struct FILE;

extern
{
    char* realpath(char* filename, mut char* resolved_name);
    i32 sprintf(mut char* str, char* format, ...);
    i32 fprintf(mut FILE* stream, char* format, ...);
}

export struct Parser
{
    Module* module;

    Lexer lexer;

    Compound* translation_unit;

    Token* token;

    CoreScope* current_scope;

    b8 panic;
    b8 failed;

    Arena arena;

    List import_stmts;
    VarTable var_table;
}

export void parser_init(mut Parser* parser, Module* module, char* filepath)
{
    frx::assert(parser != nullptr);

    frx::assert(module != nullptr);

    frx::assert(filepath != nullptr);

    parser->module = module;

    lexer_init(&parser->lexer, filepath);

    parser->translation_unit = nullptr;

    parser->token = lexer_peek(&parser->lexer, 0);

    parser->current_scope = scope_create(nullptr);

    parser->panic = false;
    parser->failed = false;

    arena_init(&parser->arena, 1024 * 1024);

    list_init(&parser->import_stmts);
    var_table_init(&parser->var_table);
}

export void parser_advance(Parser* parser)
{
    frx::assert(parser != nullptr);

    lexer_next_token(&parser->lexer);
}

export void parser_eat(mut Parser* parser, TokenType type)
{
    if(parser->token->type != type)
    {
        log_error(parser_source_file(parser), parser_current_location(parser),
                "Expected '%s', but found '%s'!", token_type_to_str(type),
                token_type_to_str(parser->token->type));

        parser_fail(parser);
        parser_panic(parser);
        return;
    }

    parser_advance(parser);
}

export b8 parser_loop_until(Parser* parser, TokenType type)
{
    frx::assert(parser != nullptr);

    frx::assert(type < TokenType::COUNT);

    TokenType current_type = parser->token->type;

    return current_type != type
        && current_type != TokenType::EOF
        && !token_type_is_synchronizing(current_type);
}

export void parser_panic(Parser* parser)
{
    frx::assert(parser != nullptr);

    while(true)
    {
        if(token_type_is_synchronizing(parser->token->type))
        {
            return;
        }

        parser_advance(parser);
    }
}

export void parser_fail(mut Parser* parser)
{
    frx::assert(parser != nullptr);

    parser->failed = true;
}

export void parser_parse(mut Parser* parser)
{
    frx::assert(parser != nullptr);

    parser->translation_unit = translation_unit_parse(parser);

    if(lexer_failed(&parser->lexer))
    {
        parser_fail(parser);
    }
}

export Symbol* parser_find_symbol(Parser* parser, SymbolType type, char* name)
{
    frx::assert(parser != nullptr);

    mut Symbol* symbol = symbol_table_find(&parser->module->symbol_table, type, name);
    if(symbol == nullptr)
    {
        mut usize i;
        for(i = 0; i < list_size(&parser->import_stmts); ++i)
        {
            ImportStmt* import_stmt = list_get(&parser->import_stmts, i);
            if(libc_strcmp(import_stmt->symbol, name) != 0)
            {
                continue;
            }

            symbol = symbol_table_find(&import_stmt->module->symbol_table, type, name);

            break;
        }

    }

    return symbol;
}

export void parser_resolve_symbols(Parser* parser)
{
    frx::assert(parser != nullptr);

    mut usize i;
    for(i = 0; i < list_size(&parser->translation_unit->nodes); ++i)
    {
        GlobalScope* global_scope = list_get(&parser->translation_unit->nodes, i);
        global_scope_resolve_symbols(parser, global_scope);
    }
}

export void parser_analyze(Parser* parser)
{
    frx::assert(parser != nullptr);

    mut usize i;
    for(i = 0; i < list_size(&parser->translation_unit->nodes); ++i)
    {
        GlobalScope* global_scope = list_get(&parser->translation_unit->nodes, i);
        global_scope_sema(parser, global_scope);
    }
}

export void parser_next_token(Parser* parser)
{
    lexer_next_token(&parser->lexer);
}

export Token* parser_peek(Parser* parser, usize offset)
{
    frx::assert(parser != nullptr);

    return lexer_peek(&parser->lexer, offset);
}

export SourceLocation parser_current_location(Parser* parser)
{
    frx::assert(parser != nullptr);

    return parser->token->range.start;
}

export char* parser_source_file(Parser* parser)
{
    frx::assert(parser != nullptr);

    return lexer_source_file(&parser->lexer);
}

export void parser_destroy(Parser* parser)
{
    frx::assert(parser != nullptr);

    lexer_destroy(&parser->lexer);
}

export void parser_push_scope(mut Parser* parser)
{
    frx::assert(parser != nullptr);

    parser->current_scope = scope_create(parser->current_scope);
}

export void parser_pop_scope(mut Parser* parser)
{
    frx::assert(parser != nullptr);

    parser->current_scope = parser->current_scope->parent;
}
