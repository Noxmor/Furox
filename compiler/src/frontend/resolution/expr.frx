import "../ast/expr.frx";
import "../core/parser.frx";
import "enum_constant.frx";
import "func_call.frx";
import "internal_func_call.frx";
import "unresolved_identifier.frx";
import "unary_expr.frx";
import "binary_expr.frx";

export void expr_resolve_symbols(Parser* parser, Expr* expr)
{
    frx::assert(parser != nullptr);

    frx::assert(expr != nullptr);

    switch(expr->type)
    {
        case ExprType::ENUM_CONSTANT:
        {
            enum_constant_resolve_symbols(parser, expr->enum_constant);

            break;
        }
        case ExprType::FUNC_CALL:
        {
            func_call_resolve_symbols(parser, expr->func_call);

            break;
        }
        case ExprType::INTERNAL_FUNC_CALL:
        {
            internal_func_call_resolve_symbols(parser, expr->internal_func_call);

            break;
        }
        case ExprType::UNRESOLVED_IDENTIFIER:
        {
            unresolved_identifier_resolve_symbols(parser, expr->unresolved_identifier);

            break;
        }
        case ExprType::UNARY_EXPR:
        {
            unary_expr_resolve_symbols(parser, expr->unary_expr);

            break;
        }
        case ExprType::BINARY_EXPR:
        {
            binary_expr_resolve_symbols(parser, expr->binary_expr);

            break;
        }

        default:
        {
            break;
        }
    }
}
