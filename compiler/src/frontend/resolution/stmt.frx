import "../ast/stmt.frx";
import "../core/parser.frx";
import "return_stmt.frx";
import "expr_stmt.frx";
import "var_decl.frx";
import "var_def.frx";
import "if_stmt.frx";
import "for_loop.frx";
import "while_loop.frx";
import "do_while_loop.frx";
import "switch_stmt.frx";
import "scope.frx";

export void stmt_resolve_symbols(Parser* parser, Stmt* stmt)
{
    frx::assert(parser != nullptr);

    frx::assert(stmt != nullptr);

    switch(stmt->type)
    {
        case StmtType::RETURN_STMT:
        {
            return_stmt_resolve_symbols(parser, stmt->return_stmt);

            break;
        }
        case StmtType::EXPR_STMT:
        {
            expr_stmt_resolve_symbols(parser, stmt->expr_stmt);

            break;
        }
        case StmtType::VAR_DECL:
        {
            var_decl_resolve_symbols(parser, stmt->var_decl);

            break;
        }
        case StmtType::VAR_DEF:
        {
            var_def_resolve_symbols(parser, stmt->var_def);

            break;
        }
        case StmtType::IF_STMT:
        {
            if_stmt_resolve_symbols(parser, stmt->if_stmt);

            break;
        }
        case StmtType::FOR_LOOP:
        {
            for_loop_resolve_symbols(parser, stmt->for_loop);

            break;
        }
        case StmtType::WHILE_LOOP:
        {
            while_loop_resolve_symbols(parser, stmt->while_loop);

            break;
        }
        case StmtType::DO_WHILE_LOOP:
        {
            do_while_loop_resolve_symbols(parser, stmt->do_while_loop);

            break;
        }
        case StmtType::SWITCH_STMT:
        {
            switch_stmt_resolve_symbols(parser, stmt->switch_stmt);

            break;
        }
        case StmtType::SCOPE:
        {
            scope_resolve_symbols(parser, stmt->scope);

            break;
        }

        default:
        {
            break;
        }
    }
}
