import "expr.frx";
import "struct_member.frx";
import "../core/errors.frx";
import "../core/parser.frx";
import "../symbols/var.frx";
import "../ast/binary_expr.frx";
import "../ast/struct_member.frx";
import "../ast/unresolved_identifier.frx";
import "../syntax/var.frx";

export void binary_expr_sema(mut Parser* parser, mut BinaryExpr* expr)
{
    frx::assert(parser != nullptr);

    frx::assert(expr != nullptr);

    switch(expr->operator)
    {
        case Operator::POINTER_MEMBER_ACCESS:
            {
                expr_sema(parser, expr->left);

                if(expr->right->type != ExprType::UNRESOLVED_IDENTIFIER)
                {
                    //FIXME: Print the correct location, this is only a placeholder
                    SourceLocation loc;
                    error_not_a_struct_member(parser_source_file(parser), loc);

                    parser_fail(parser);
                }
                else
                {
                    UnresolvedIdentifier* unresolved_identifier = expr->right->unresolved_identifier;
                    StructMember* member = struct_member_new(&parser->arena, unresolved_identifier->name);

                    expr->right->type = ExprType::STRUCT_MEMBER;
                    expr->right->struct_member = member;

                    struct_member_sema(parser, member);
                }

                break;
            }
        case Operator::MEMBER_ACCESS:
            {
                expr_sema(parser, expr->left);

                if(expr->right->type != ExprType::UNRESOLVED_IDENTIFIER)
                {
                    //FIXME: Print the correct location, this is only a placeholder
                    SourceLocation loc;
                    error_not_a_struct_member(parser_source_file(parser), loc);

                    parser_fail(parser);
                }
                else
                {
                    UnresolvedIdentifier* unresolved_identifier = expr->right->unresolved_identifier;
                    StructMember* member = struct_member_new(&parser->arena, unresolved_identifier->name);

                    expr->right->type = ExprType::STRUCT_MEMBER;
                    expr->right->struct_member = member;

                    struct_member_sema(parser, member);
                }

                break;
            }
        case Operator::ASSIGN:
            {
                expr_sema(parser, expr->left);
                expr_sema(parser, expr->right);

                mut Expr* left = expr->left;
                while(left->type == ExprType::BINARY_EXPR)
                {
                    BinaryExpr* binary_expr = left->binary_expr;
                    if(binary_expr->operator != Operator::POINTER_MEMBER_ACCESS
                            && binary_expr->operator != Operator::MEMBER_ACCESS)
                    {
                        break;
                    }

                    left = binary_expr->left;
                }

                if(left->type == ExprType::VAR)
                {
                    Var* var = left->var;
                    VarSymbol* symbol = var->symbol;

                    if(!symbol->mutable)
                    {
                        error_assignment_const_var(parser_source_file(parser),
                                var->range.start, var->name);
                        parser_fail(parser);
                    }
                }

                break;
            }
        default:
            {
                expr_sema(parser, expr->left);
                expr_sema(parser, expr->right);

                break;
            }
    }
}
