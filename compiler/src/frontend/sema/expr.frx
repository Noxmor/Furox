export import "../ast/expr.frx";
import "../core/parser.frx";
import "enum_constant.frx";
import "func_call.frx";
import "internal_func_call.frx";
import "var.frx";
import "struct_member.frx";
import "unresolved_name.frx";
import "unresolved_namespaced_name.frx";
import "initializer_list.frx";
import "unary_expr.frx";
import "binary_expr.frx";

namespace AST::Expr
{
    export void sema(Parser* parser, mut Expr* expr)
    {
        switch(expr->type)
        {
            case AST::ExprType::INT_LITERAL:
            {
                break;
            }

            case AST::ExprType::FLOAT_LITERAL:
            {
                break;
            }

            case AST::ExprType::CHAR_LITERAL:
            {
                break;
            }

            case AST::ExprType::STRING_LITERAL:
            {
                break;
            }

            case AST::ExprType::ENUM_CONSTANT:
            {
                AST::EnumConstant::sema(parser, expr->enum_constant);

                break;
            }

            case AST::ExprType::FUNC_CALL:
            {
                AST::FuncCall::sema(parser, expr->func_call);

                break;
            }

            case AST::ExprType::INTERNAL_FUNC_CALL:
            {
                AST::InternalFuncCall::sema(parser, expr->internal_func_call, expr);

                break;
            }

            case AST::ExprType::VAR:
            {
                AST::Var::sema(parser, expr->var);

                break;
            }

            case AST::ExprType::STRUCT_MEMBER:
            {
                AST::StructMember::sema(parser, expr->struct_member);

                break;
            }

            case AST::ExprType::UNRESOLVED_NAME:
            {
                AST::UnresolvedName::sema(parser, expr->unresolved_name, expr);

                break;
            }

            case AST::ExprType::UNRESOLVED_NAMESPACED_NAME:
            {
                AST::UnresolvedNamespacedName::sema(parser, expr->unresolved_namespaced_name, expr);

                break;
            }

            case AST::ExprType::INITIALIZER_LIST:
            {
                AST::InitializerList::sema(parser, expr->initializer_list);

                break;
            }

            case AST::ExprType::UNARY_EXPR:
            {
                AST::UnaryExpr::sema(parser, expr->unary_expr);

                break;
            }

            case AST::ExprType::BINARY_EXPR:
            {
                AST::BinaryExpr::sema(parser, expr->binary_expr);

                break;
            }

            default:
            {
                frx::assert(false);

                break;
            }
        }
    }
}
