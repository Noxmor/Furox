import "expr.frx";
import "../core/errors.frx";
import "../core/parser.frx";
import "../symbols/enum.frx";
import "../symbols/struct.frx";
import "../ast/int_literal.frx";
import "../ast/internal_func_call.frx";

export void assert_sema(Parser* parser, Assert* assert_node)
{
    frx::assert(parser != nullptr);

    frx::assert(assert_node != nullptr);

    expr_sema(parser, assert_node->expr);
}

export void sizeof_sema(mut Parser* parser, mut Sizeof* sizeof_node)
{
    frx::assert(parser != nullptr);

    frx::assert(sizeof_node != nullptr);

    if(sizeof_node->primitive_type != TokenType::EOF)
    {
        return;
    }

    CoreNamespace* ns = sizeof_node->resolution->ns;

    if(ns == nullptr && !namespace_resolution_is_absolute(sizeof_node->resolution))
    {
        sizeof_node->struct_type = parser_find_struct_symbol_r(parser,
                nullptr, sizeof_node->name);

        sizeof_node->enum_type = parser_find_enum_symbol_r(parser,
                nullptr, sizeof_node->name);
    }
    else
    {
        sizeof_node->struct_type = parser_find_struct_symbol(parser, ns, sizeof_node->name);
        sizeof_node->enum_type = parser_find_enum_symbol(parser, ns, sizeof_node->name);
    }

    if(sizeof_node->enum_type == nullptr
            && sizeof_node->struct_type == nullptr)
    {
        //FIXME: Print the correct location, this is only a placeholder
        SourceLocation loc;
        error_sizeof_invalid_arg(parser_source_file(parser), loc,
                sizeof_node->name);

        parser_fail(parser);
    }
}

export void enum_count_sema(mut Parser* parser, EnumCount* enum_count, mut Expr* expr)
{
    frx::assert(parser != nullptr);

    frx::assert(enum_count != nullptr);

    mut EnumSymbol* symbol = nullptr;
    CoreNamespace* ns = enum_count->resolution->ns;

    if(ns == nullptr && !namespace_resolution_is_absolute(enum_count->resolution))
    {
        symbol = parser_find_enum_symbol_r(parser, nullptr, enum_count->name);
    }
    else
    {
        symbol = parser_find_enum_symbol(parser, ns, enum_count->name);
    }

    if(symbol == nullptr)
    {
        //FIXME: Print the correct location, this is only a placeholder
        SourceLocation loc;
        error_enum_count_invalid_arg(parser->lexer.filepath, loc,
                enum_count->name);
        parser_fail(parser);
    }
    else
    {
        expr->type = ExprType::INT_LITERAL;
        expr->int_literal = int_literal_new(&parser->arena,
                list_size(&symbol->constants));
    }
}

export void internal_func_call_sema(Parser* parser, InternalFuncCall* internal_func_call, mut Expr* expr)
{
    frx::assert(parser != nullptr);

    frx::assert(internal_func_call != nullptr);

    switch(internal_func_call->type)
    {
        case InternalFuncCallType::ASSERT:
            {
                assert_sema(parser, internal_func_call->assert_node);

                break;
            }

        case InternalFuncCallType::SIZEOF:
            {
                sizeof_sema(parser, internal_func_call->sizeof_node);

                break;
            }

        case InternalFuncCallType::ENUM_COUNT:
            {
                enum_count_sema(parser, internal_func_call->enum_count_node, expr);

                break;
            }

        default:
            {
                frx::assert(false);

                break;
            }
    }
}
