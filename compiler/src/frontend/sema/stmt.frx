export import "../ast/stmt.frx";
import "../core/parser.frx";
import "return_stmt.frx";
import "expr_stmt.frx";
import "var_decl.frx";
import "var_def.frx";
import "if_stmt.frx";
import "for_loop.frx";
import "while_loop.frx";
import "do_while_loop.frx";
import "switch_stmt.frx";
import "scope.frx";

export void stmt_sema(Parser* parser, Stmt* stmt)
{
    frx::assert(parser != nullptr);

    frx::assert(stmt != nullptr);

    switch(stmt->type)
    {
        case StmtType::BREAK_STMT:
            {
                break;
            }

        case StmtType::CONTINUE_STMT:
            {
                break;
            }

        case StmtType::RETURN_STMT:
            {
                return_stmt_sema(parser, stmt->return_stmt);

                break;
            }

        case StmtType::EXPR_STMT:
            {
                expr_stmt_sema(parser, stmt->expr_stmt);

                break;
            }

        case StmtType::VAR_DECL:
            {
                var_decl_sema(parser, stmt->var_decl);

                break;
            }

        case StmtType::VAR_DEF:
            {
                var_def_sema(parser, stmt->var_def);

                break;
            }

        case StmtType::IF_STMT:
            {
                if_stmt_sema(parser, stmt->if_stmt);

                break;
            }

        case StmtType::FOR_LOOP:
            {
                for_loop_sema(parser, stmt->for_loop);

                break;
            }

        case StmtType::WHILE_LOOP:
            {
                while_loop_sema(parser, stmt->while_loop);

                break;
            }

        case StmtType::DO_WHILE_LOOP:
            {
                do_while_loop_sema(parser, stmt->do_while_loop);

                break;
            }

        case StmtType::SWITCH_STMT:
            {
                switch_stmt_sema(parser, stmt->switch_stmt);

                break;
            }

        case StmtType::SCOPE:
            {
                scope_sema(parser, stmt->scope);

                break;
            }

        default:
            {
                frx::assert(false);

                break;
            }
    }
}
