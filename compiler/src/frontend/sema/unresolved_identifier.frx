import "expr.frx";
import "../ast/enum_constant.frx";
import "../core/errors.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../symbols/enum.frx";
import "../symbols/var.frx";
import "../ast/unresolved_identifier.frx";
import "../ast/var.frx";
import "../../core/symbol_table.frx";

export void unresolved_identifier_sema(mut Parser* parser, UnresolvedIdentifier* unresolved_identifier, mut Expr* expr)
{
    frx::assert(parser != nullptr);

    frx::assert(unresolved_identifier != nullptr);

    frx::assert(unresolved_identifier->resolution != nullptr);

    CoreNamespace* ns = unresolved_identifier->resolution->ns;
    char* name = unresolved_identifier->name;
    CoreScope* scope = unresolved_identifier->scope;

    mut EnumSymbol* enum_symbol = nullptr;
    if(ns != nullptr)
    {
        Symbol* symbol = parser_find_symbol(parser, SymbolType::ENUM, ns->name);
        if(symbol != nullptr)
        {
            enum_symbol = symbol->data;
        }
    }

    b8 is_enum_constant = enum_symbol != nullptr && enum_symbol_has_constant(
            enum_symbol, name);

    VarSymbol* var_symbol = var_table_find(&parser->var_table, scope, name);
    b8 is_global_var = var_symbol != nullptr && scope_is_global(var_symbol->scope);
    b8 is_var = var_symbol != nullptr && !is_global_var;

    b8 is_ambiguous = (is_enum_constant + is_global_var + is_var) > 1;
    b8 resolved = is_enum_constant || is_global_var || is_var;

    if(is_ambiguous)
    {
        error_ambiguous_unresolved_identifier(parser_source_file(parser),
                unresolved_identifier->range.start, ns, name);
        parser_fail(parser);
    }
    else if(is_enum_constant)
    {
        expr->type = ExprType::ENUM_CONSTANT;
        expr->enum_constant = enum_constant_new(&parser->arena, enum_symbol,
            ns->parent, ns->name, name, scope);
    }
    else if(is_global_var)
    {
        expr->type = ExprType::VAR;
        expr->var = var_new(&parser->arena, ns, scope, name);
    }
    else if(is_var)
    {
        expr->type = ExprType::VAR;
        expr->var = var_new(&parser->arena, nullptr, scope, name);
    }
    else
    {
        error_unresolved_identifier(parser_source_file(parser),
                unresolved_identifier->range.start, ns, name);
        parser_fail(parser);
    }

    if(!is_ambiguous && resolved)
    {
        expr_sema(parser, expr);
    }
}
