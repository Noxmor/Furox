import "ast.frx";
import "../core/errors.frx";
import "../core/parser.frx";
import "../syntax/binary_expr.frx";

export void analyze_binary_expr(Parser* parser, ASTBinaryExpr* expr)
{
    assert(parser != nullptr);

    assert(expr != nullptr);

    switch(expr->operator)
    {
        case OP_POINTER_MEMBER_ACCESS:
        {
            analyze_ast(parser, expr->left);

            if(expr->right->type != AST_TYPE_UNRESOLVED_NAME)
            {
                //FIXME: Print the correct location, this is only a placeholder
                SourceLocation loc;
                error_not_a_struct_member(parser_source_file(parser), loc);

                parser->failed = true;
            }
            else
            {
                ASTUnresolvedName* unresolved_name = expr->right->node;
                ASTStructMember* member = make_struct_member(&parser->arena,
                    unresolved_name->name);

                expr->right->type = AST_TYPE_STRUCT_MEMBER;
                expr->right->node = member;

                analyze_struct_member(parser, member);
            }

            break;
        }
        case OP_MEMBER_ACCESS:
        {
            analyze_ast(parser, expr->left);

            if(expr->right->type != AST_TYPE_UNRESOLVED_NAME)
            {
                //FIXME: Print the correct location, this is only a placeholder
                SourceLocation loc;
                error_not_a_struct_member(parser_source_file(parser), loc);

                parser->failed = true;
            }
            else
            {
                ASTUnresolvedName* unresolved_name = expr->right->node;
                ASTStructMember* member = make_struct_member(&parser->arena,
                    unresolved_name->name);

                expr->right->type = AST_TYPE_STRUCT_MEMBER;
                expr->right->node = member;

                analyze_struct_member(parser, member);
            }

            break;
        }
        case OP_ASSIGN:
        {
            analyze_ast(parser, expr->left);
            analyze_ast(parser, expr->right);

            AST* left = expr->left;
            while(left->type == AST_TYPE_BINARY_EXPR)
            {
                ASTBinaryExpr* binary_expr = left->node;
                if(binary_expr->operator != OP_POINTER_MEMBER_ACCESS
                    && binary_expr->operator != OP_MEMBER_ACCESS)
                {
                    break;
                }

                left = binary_expr->left;
            }

            if(left->type == AST_TYPE_VAR)
            {
                ASTVar* var = left->node;
                VarSymbol* symbol = var->symbol;

                if(!symbol->mutable)
                {
                    error_assignment_const_var(parser_source_file(parser),
                        var->range.start, var->name);
                    parser->failed = true;
                }
            }

            break;
        }
        default:
        {
            analyze_ast(parser, expr->left);
            analyze_ast(parser, expr->right);

            break;
        }
    }
}
