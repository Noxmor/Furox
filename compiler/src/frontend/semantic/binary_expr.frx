import "expr.frx";
import "struct_member.frx";
import "../core/errors.frx";
import "../core/parser.frx";
import "../symbols/var.frx";
import "../ast/binary_expr.frx";
import "../ast/struct_member.frx";
import "../ast/unresolved_name.frx";
import "../syntax/var.frx";

export void analyze_binary_expr(mut Parser* parser, mut AST::BinaryExpr* expr)
{
    frx::assert(parser != nullptr);

    frx::assert(expr != nullptr);

    switch(expr->operator)
    {
        case Operator::POINTER_MEMBER_ACCESS:
        {
            analyze_expr(parser, expr->left);

            if(expr->right->type != AST::ExprType::UNRESOLVED_NAME)
            {
                //FIXME: Print the correct location, this is only a placeholder
                SourceLocation loc;
                error_not_a_struct_member(parser_source_file(parser), loc);

                parser->failed = true;
            }
            else
            {
                AST::UnresolvedName* unresolved_name = expr->right->unresolved_name;
                AST::StructMember* member = AST::StructMember::new(&parser->arena, unresolved_name->name);

                expr->right->type = AST::ExprType::STRUCT_MEMBER;
                expr->right->struct_member = member;

                analyze_struct_member(parser, member);
            }

            break;
        }
        case Operator::MEMBER_ACCESS:
        {
            analyze_expr(parser, expr->left);

            if(expr->right->type != AST::ExprType::UNRESOLVED_NAME)
            {
                //FIXME: Print the correct location, this is only a placeholder
                SourceLocation loc;
                error_not_a_struct_member(parser_source_file(parser), loc);

                parser->failed = true;
            }
            else
            {
                AST::UnresolvedName* unresolved_name = expr->right->unresolved_name;
                AST::StructMember* member = AST::StructMember::new(&parser->arena, unresolved_name->name);

                expr->right->type = AST::ExprType::STRUCT_MEMBER;
                expr->right->struct_member = member;

                analyze_struct_member(parser, member);
            }

            break;
        }
        case Operator::ASSIGN:
        {
            analyze_expr(parser, expr->left);
            analyze_expr(parser, expr->right);

            mut AST::Expr* left = expr->left;
            while(left->type == AST::ExprType::BINARY_EXPR)
            {
                AST::BinaryExpr* binary_expr = left->binary_expr;
                if(binary_expr->operator != Operator::POINTER_MEMBER_ACCESS
                    && binary_expr->operator != Operator::MEMBER_ACCESS)
                {
                    break;
                }

                left = binary_expr->left;
            }

            if(left->type == AST::ExprType::VAR)
            {
                AST::Var* var = left->var;
                VarSymbol* symbol = var->symbol;

                if(!symbol->mutable)
                {
                    error_assignment_const_var(parser_source_file(parser),
                        var->range.start, var->name);
                    parser->failed = true;
                }
            }

            break;
        }
        default:
        {
            analyze_expr(parser, expr->left);
            analyze_expr(parser, expr->right);

            break;
        }
    }
}
