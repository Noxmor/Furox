import "ast.frx";
import "../core/errors.frx";
import "../core/parser.frx";
import "../syntax/binary_expr.frx";

export void analyze_binary_expr(Parser* parser, ASTBinaryExpr* expr)
{
    assert(parser != nullptr);

    assert(expr != nullptr);

    switch(expr->operator)
    {
        case OP_POINTER_MEMBER_ACCESS:
        {
            analyze_ast(parser, expr->left);

            if(expr->right->type != AST_TYPE_VAR)
            {
                //FIXME: Print the correct location, this is only a placeholder
                SourceLocation loc;
                error_not_a_struct_member(parser_source_file(parser), loc);

                parser->failed = true;
            }
            else
            {
                ASTVar* var = expr->right->node;
                ASTStructMember* member = make_struct_member(&parser->arena,
                    var->name);

                expr->right->type = AST_TYPE_STRUCT_MEMBER;
                expr->right->node = member;

                analyze_struct_member(parser, member);
            }

            break;
        }
        case OP_MEMBER_ACCESS:
        {
            analyze_ast(parser, expr->left);

            if(expr->right->type != AST_TYPE_VAR)
            {
                //FIXME: Print the correct location, this is only a placeholder
                SourceLocation loc;
                error_not_a_struct_member(parser_source_file(parser), loc);

                parser->failed = true;
            }
            else
            {
                ASTVar* var = expr->right->node;
                ASTStructMember* member = make_struct_member(&parser->arena,
                    var->name);

                expr->right->type = AST_TYPE_STRUCT_MEMBER;
                expr->right->node = member;

                analyze_struct_member(parser, member);
            }

            break;
        }
        default:
        {
            analyze_ast(parser, expr->left);
            analyze_ast(parser, expr->right);

            break;
        }
    }
}
