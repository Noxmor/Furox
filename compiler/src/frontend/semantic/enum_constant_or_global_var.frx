import "ast.frx";
import "../core/parser.frx";
import "../syntax/enum_constant_or_global_var.frx";

export void analyze_enum_constant_or_global_var(Parser* parser,
    ASTEnumConstantOrGlobalVar* enum_constant_or_global_var, AST* ast)
{
    assert(parser != nullptr);

    assert(enum_constant_or_global_var != nullptr);

    Namespace* ns = enum_constant_or_global_var->ns;
    char* name = enum_constant_or_global_var->name;
    Scope* scope = enum_constant_or_global_var->scope;

    EnumSymbol* enum_symbol = parser_find_enum_symbol(parser, ns->parent,
        ns->name);

    b8 is_enum_constant = enum_symbol != nullptr && enum_symbol_has_constant(
        enum_symbol, name);

    b8 is_global_var = var_table_find_by_namespace(&parser->var_table, ns, name)
        != nullptr;

    b8 is_ambiguous = is_enum_constant && is_global_var;
    if(is_ambiguous)
    {
        //FIXME: Print the correct location, this is only a placeholder
        SourceLocation loc;
        error_ambiguous_enum_constant_or_global_var(parser_source_file(parser),
            loc, ns, name);
        parser->failed = true;
    }
    else if(is_enum_constant)
    {
        ast->type = AST_TYPE_ENUM_CONSTANT;
        ast->node = make_enum_constant(&parser->arena, ns->parent, ns->name,
            name, scope);
    }
    else
    {
        ast->type = AST_TYPE_VAR;
        ast->node = make_var(&parser->arena, ns,
            enum_constant_or_global_var->scope, name);
    }

    if(!is_ambiguous)
    {
        analyze_ast(parser, ast);
    }
}
