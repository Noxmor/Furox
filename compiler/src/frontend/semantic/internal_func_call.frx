import "expr.frx";
import "../core/errors.frx";
import "../core/parser.frx";
import "../symbols/enum.frx";
import "../symbols/struct.frx";
import "../ast/int_literal.frx";
import "../ast/internal_func_call.frx";

export void analyze_assert(Parser* parser, AST::Assert* assert_node)
{
    frx::assert(parser != nullptr);

    frx::assert(assert_node != nullptr);

    analyze_expr(parser, assert_node->expr);
}

export void analyze_sizeof(mut Parser* parser, mut AST::Sizeof* sizeof_node)
{
    frx::assert(parser != nullptr);

    frx::assert(sizeof_node != nullptr);

    if(sizeof_node->primitive_type != TokenType::ERROR)
    {
        return;
    }

    if(sizeof_node->ns == nullptr)
    {
        sizeof_node->struct_type = parser_find_struct_symbol_r(parser,
            parser->current_namespace, sizeof_node->name);

        sizeof_node->enum_type = parser_find_enum_symbol_r(parser,
            parser->current_namespace, sizeof_node->name);
    }
    else
    {
        sizeof_node->struct_type = parser_find_struct_symbol(parser,
            sizeof_node->ns, sizeof_node->name);
        sizeof_node->enum_type = parser_find_enum_symbol(parser,
            sizeof_node->ns, sizeof_node->name);
    }

    if(sizeof_node->enum_type == nullptr
        && sizeof_node->struct_type == nullptr)
    {
        //FIXME: Print the correct location, this is only a placeholder
        SourceLocation loc;
        error_sizeof_invalid_arg(parser_source_file(parser), loc,
            sizeof_node->name);

        parser->failed = true;
    }
}

export void analyze_enum_count(mut Parser* parser, AST::EnumCount* enum_count,
    mut AST::Expr* expr)
{
    frx::assert(parser != nullptr);

    frx::assert(enum_count != nullptr);

    mut EnumSymbol* symbol = nullptr;

    if(enum_count->ns == nullptr)
    {
        symbol = parser_find_enum_symbol_r(parser, parser->current_namespace,
            enum_count->name);
    }
    else
    {
        symbol = parser_find_enum_symbol(parser, enum_count->ns,
            enum_count->name);
    }

    if(symbol == nullptr)
    {
        //FIXME: Print the correct location, this is only a placeholder
        SourceLocation loc;
        error_enum_count_invalid_arg(parser->lexer.filepath, loc,
            enum_count->name);
        parser->failed = true;
    }
    else
    {
        expr->type = AST::ExprType::INT_LITERAL;
        expr->int_literal = AST::IntLiteral::new(&parser->arena,
            list_size(&symbol->constants));
    }
}

export void analyze_internal_func_call(Parser* parser, AST::InternalFuncCall* internal_func_call,
    mut AST::Expr* expr)
{
    frx::assert(parser != nullptr);

    frx::assert(internal_func_call != nullptr);

    switch(internal_func_call->type)
    {
        case AST::InternalFuncCallType::ASSERT:
        {
            analyze_assert(parser, internal_func_call->assert_node);

            break;
        }

        case AST::InternalFuncCallType::SIZEOF:
        {
            analyze_sizeof(parser, internal_func_call->sizeof_node);

            break;
        }

        case AST::InternalFuncCallType::ENUM_COUNT:
        {
            analyze_enum_count(parser, internal_func_call->enum_count_node, expr);

            break;
        }

        default:
        {
            frx::assert(false);

            break;
        }
    }
}
