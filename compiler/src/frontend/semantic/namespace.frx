import "ast.frx";
import "../core/errors.frx";
import "../core/parser.frx";
import "../syntax/namespace.frx";

export void analyze_namespace(Parser* parser, ASTNamespace* namespace_node)
{
    assert(parser != nullptr);

    assert(namespace_node != nullptr);

    Namespace* ns = namespace_node->ns;

    if(namespace_is_internal(ns))
    {
        SourceLocation loc;
        error_namespace_is_reserved(parser->lexer.filepath, loc, ns);
        parser->failed = true;
    }

    //TODO: Actually allow this
    /*if(enum_table_find(ns->parent, ns->name) != nullptr)
    {
        SourceLocation loc;
        error_namespace_enum_conflict(parser->lexer.filepath, loc, ns->name);
        parser->failed = true;
    }*/

    Namespace* old_namespace = parser->current_namespace;
    parser->current_namespace = ns;

    usize i;
    for(i = 0; i < list_size(&namespace_node->global_scope); i = i + 1)
    {
        AST* ast = list_get(&namespace_node->global_scope, i);
        analyze_ast(parser, ast);
    }

    parser->current_namespace = old_namespace;
}
