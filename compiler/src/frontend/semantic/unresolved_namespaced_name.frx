import "expr.frx";
import "../ast/enum_constant.frx";
import "../core/errors.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../symbols/enum.frx";
import "../symbols/var.frx";
import "../ast/unresolved_namespaced_name.frx";
import "../ast/var.frx";

export void analyze_unresolved_namespaced_name(mut Parser* parser,
    AST::UnresolvedNamespacedName* unresolved_namespaced_name, mut AST::Expr* expr)
{
    frx::assert(parser != nullptr);

    frx::assert(unresolved_namespaced_name != nullptr);

    core::Namespace* ns = unresolved_namespaced_name->ns;
    char* name = unresolved_namespaced_name->name;
    core::Scope* scope = unresolved_namespaced_name->scope;

    EnumSymbol* enum_symbol = parser_find_enum_symbol(parser, ns->parent,
        ns->name);

    b8 is_enum_constant = enum_symbol != nullptr && enum_symbol_has_constant(
        enum_symbol, name);

    b8 is_global_var = var_table_find_by_namespace(&parser->var_table, ns, name)
        != nullptr;

    b8 is_ambiguous = (is_enum_constant + is_global_var) > 1;
    b8 resolved = is_enum_constant || is_global_var;

    if(is_ambiguous)
    {
        error_ambiguous_unresolved_namespaced_name(parser_source_file(parser),
            unresolved_namespaced_name->range.start, ns, name);
        parser->failed = true;
    }
    else if(is_enum_constant)
    {
        expr->type = AST::ExprType::ENUM_CONSTANT;
        expr->enum_constant = AST::EnumConstant::new(&parser->arena, ns->parent, ns->name,
            name, scope);
    }
    else if(is_global_var)
    {
        expr->type = AST::ExprType::VAR;
        expr->var = AST::Var::new(&parser->arena, ns, scope, name);
    }
    else
    {
        error_unresolved_namespaced_name(parser_source_file(parser),
            unresolved_namespaced_name->range.start, ns, name);
        parser->failed = true;
    }

    if(!is_ambiguous && resolved)
    {
        analyze_expr(parser, expr);
    }
}
