import "../core/namespace.frx";
import "../core/scope.frx";
import "../core/token.frx";
import "../../core/list.frx";

export struct EnumSymbol
{
    TokenType type;
    Scope* scope;
    Namespace* ns;
    char* name;
    List constants;
    b8 exported;
}

export void enum_symbol_init(EnumSymbol* symbol, TokenType type, Scope* scope,
    Namespace* ns, char* name, b8 exported)
{
    assert(symbol != nullptr);

    assert(type != TOKEN_TYPE_ERROR && type < TOKEN_TYPE_COUNT);

    assert(scope != nullptr);

    assert(name != nullptr);

    symbol->type = type;
    symbol->scope = scope;
    symbol->ns = ns;
    symbol->name = name;
    list_init(&symbol->constants);
    symbol->exported = exported;
}

b8 enum_symbol_has_constant(EnumSymbol* symbol, char* name)
{
    assert(symbol != nullptr);

    assert(name != nullptr);

    usize i;
    for(i = 0; i < list_size(&symbol->constants); i = i + 1)
    {
        ASTEnumConstantDef* constant = list_get(&symbol->constants, i);
        if(strcmp(constant->name, name) == 0)
        {
            return true;
        }
    }

    return false;
}

struct EnumTableEntry
{
    EnumSymbol* symbol;
    EnumTableEntry* next;
}

macro ENUM_TABLE_CAPACITY = 128;

export struct EnumTable
{
    EnumTableEntry*[ENUM_TABLE_CAPACITY] entries;
}

export void enum_table_init(EnumTable* table)
{
    assert(table != nullptr);

    memset(table, 0, sizeof(EnumTable));
}

export EnumSymbol* enum_table_find_r(EnumTable* table, Namespace* ns,
    char* name)
{
    EnumSymbol* symbol = enum_table_find(table, ns, name);
    while(symbol == nullptr && ns != nullptr)
    {
        ns = ns->parent;
        symbol = enum_table_find(table, ns, name);
    }

    return symbol;
}

export EnumSymbol* enum_table_find(EnumTable* table, Namespace* ns, char* name)
{
    assert(table != nullptr);

    assert(name != nullptr);

    u64 index = hash_djb2(name) % ENUM_TABLE_CAPACITY;
    EnumTableEntry* entry = table->entries[index];

    while(entry != nullptr)
    {
        EnumSymbol* symbol = entry->symbol;

        if(strcmp(symbol->name, name) == 0 && namespace_equals(symbol->ns, ns))
        {
            return symbol;
        }

        entry = entry->next;
    }

    return nullptr;
}

export b8 enum_table_insert(EnumTable* table, EnumSymbol* symbol)
{
    assert(table != nullptr);

    assert(symbol != nullptr);

    u64 index = hash_djb2(symbol->name) % ENUM_TABLE_CAPACITY;
    EnumTableEntry* entry = table->entries[index];

    while(entry != nullptr)
    {
        EnumSymbol* existing_symbol = entry->symbol;

        if(strcmp(existing_symbol->name, symbol->name) == 0
            && namespace_equals(existing_symbol->ns, symbol->ns))
        {
            return false;
        }

        entry = entry->next;
    }

    EnumTableEntry* new_entry = malloc(sizeof(EnumTableEntry));
    new_entry->symbol = symbol;
    new_entry->next = table->entries[index];

    table->entries[index] = new_entry;

    return true;
}
