struct EnumTableEntry
{
    ASTEnumDef* enum_def;
    EnumTableEntry* next;
}

macro ENUM_TABLE_CAPACITY = 128;

struct EnumTable
{
    EnumTableEntry*[ENUM_TABLE_CAPACITY] entries;
}

EnumTable enum_table;

export ASTEnumDef* enum_table_find_r(Namespace* ns, char* name)
{
    ASTEnumDef* enum_def = enum_table_find(ns, name);
    while(enum_def == nullptr && ns != nullptr)
    {
        ns = ns->parent;
        enum_def = enum_table_find(ns, name);
    }

    return enum_def;
}

export ASTEnumDef* enum_table_find(Namespace* ns, char* name)
{
    assert(name != nullptr);

    u64 index = hash_djb2(name) % ENUM_TABLE_CAPACITY;
    EnumTableEntry* entry = enum_table.entries[index];

    while(entry != nullptr)
    {
        ASTEnumDef* enum_def = entry->enum_def;

        if(strcmp(enum_def->name, name) == 0 && namespace_equals(enum_def->ns,
            ns))
        {
            return enum_def;
        }

        entry = entry->next;
    }

    return nullptr;
}

export ASTEnumDef* enum_table_insert(ASTEnumDef* enum_def)
{
    assert(enum_def != nullptr);

    u64 index = hash_djb2(enum_def->name) % ENUM_TABLE_CAPACITY;
    EnumTableEntry* entry = enum_table.entries[index];

    while(entry != nullptr)
    {
        ASTEnumDef* existing_enum_def = entry->enum_def;

        if(strcmp(existing_enum_def->name, enum_def->name) == 0
            && namespace_equals(existing_enum_def->ns, enum_def->ns))
        {
            return nullptr;
        }

        entry = entry->next;
    }

    EnumTableEntry* new_entry = malloc(sizeof(EnumTableEntry));
    new_entry->enum_def = enum_def;
    new_entry->next = enum_table.entries[index];

    enum_table.entries[index] = new_entry;

    return enum_def;
}
