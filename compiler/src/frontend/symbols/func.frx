struct FuncTableEntry
{
    ASTFuncDef* func_def;
    FuncTableEntry* next;
}

macro FUNC_TABLE_CAPACITY = 128;

struct FuncTable
{
    FuncTableEntry*[FUNC_TABLE_CAPACITY] entries;
}

FuncTable func_table;

export ASTFuncDef* func_table_find_r(Namespace* ns, char* name)
{
    ASTFuncDef* func_def = func_table_find(ns, name);
    while(func_def == nullptr && ns != nullptr)
    {
        ns = ns->parent;
        func_def = func_table_find(ns, name);
    }

    return func_def;
}

export ASTFuncDef* func_table_find(Namespace* ns, char* name)
{
    assert(name != nullptr);

    u64 index = hash_djb2(name) % FUNC_TABLE_CAPACITY;
    FuncTableEntry* entry = func_table.entries[index];

    while(entry != nullptr)
    {
        ASTFuncDef* func_def = entry->func_def;

        if(strcmp(func_def->name, name) == 0 && namespace_equals(func_def->ns,
            ns))
        {
            return func_def;
        }

        entry = entry->next;
    }

    return nullptr;
}

export ASTFuncDef* func_table_insert(ASTFuncDef* func_def)
{
    assert(func_def != nullptr);

    u64 index = hash_djb2(func_def->name) % FUNC_TABLE_CAPACITY;
    FuncTableEntry* entry = func_table.entries[index];

    while(entry != nullptr)
    {
        ASTFuncDef* existing_func_def = entry->func_def;

        if(strcmp(existing_func_def->name, func_def->name) == 0
            && namespace_equals(existing_func_def->ns, func_def->ns))
        {
            return nullptr;
        }

        entry = entry->next;
    }

    FuncTableEntry* new_entry = malloc(sizeof(FuncTableEntry));
    new_entry->func_def = func_def;
    new_entry->next = func_table.entries[index];

    func_table.entries[index] = new_entry;

    return func_def;
}
