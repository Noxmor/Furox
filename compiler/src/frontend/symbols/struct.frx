struct StructTableEntry
{
    ASTStructDef* struct_def;
    StructTableEntry* next;
}

macro STRUCT_TABLE_CAPACITY = 128;

struct StructTable
{
    StructTableEntry*[STRUCT_TABLE_CAPACITY] entries;
}

StructTable struct_table;

export ASTStructDef* struct_table_find_r(Namespace* ns, char* name)
{
    ASTStructDef* struct_def = struct_table_find(ns, name);
    while(struct_def == nullptr && ns != nullptr)
    {
        ns = ns->parent;
        struct_def = struct_table_find(ns, name);
    }

    return struct_def;
}

export ASTStructDef* struct_table_find(Namespace* ns, char* name)
{
    assert(name != nullptr);

    u64 index = hash_djb2(name) % STRUCT_TABLE_CAPACITY;
    StructTableEntry* entry = struct_table.entries[index];

    while(entry != nullptr)
    {
        ASTStructDef* struct_def = entry->struct_def;

        if(strcmp(struct_def->name, name) == 0
            && namespace_equals(struct_def->ns, ns))
        {
            return struct_def;
        }

        entry = entry->next;
    }

    return nullptr;
}

export ASTStructDef* struct_table_insert(ASTStructDef* struct_def)
{
    assert(struct_def != nullptr);

    u64 index = hash_djb2(struct_def->name) % STRUCT_TABLE_CAPACITY;
    StructTableEntry* entry = struct_table.entries[index];

    while(entry != nullptr)
    {
        ASTStructDef* existing_struct_def = entry->struct_def;

        if(strcmp(existing_struct_def->name, struct_def->name) == 0
            && namespace_equals(existing_struct_def->ns, struct_def->ns))
        {
            return nullptr;
        }

        entry = entry->next;
    }

    StructTableEntry* new_entry = malloc(sizeof(StructTableEntry));
    new_entry->struct_def = struct_def;
    new_entry->next = struct_table.entries[index];

    struct_table.entries[index] = new_entry;

    return struct_def;
}
