export struct VarSymbol
{
    ASTTypeSpecifier* type;
    Scope* scope;
    char* name;
}

struct VarTableEntry
{
    VarSymbol* symbol;
    VarTableEntry* next;
}

macro VAR_TABLE_CAPACITY = 128;

struct VarTable
{
    VarTableEntry*[VAR_TABLE_CAPACITY] entries;
}

VarTable var_table;

export VarSymbol* var_table_find(Scope* scope, char* name)
{
    assert(name != nullptr);

    u64 index = hash_djb2(name) % VAR_TABLE_CAPACITY;
    VarTableEntry* entry = var_table.entries[index];

    while(entry != nullptr)
    {
        VarSymbol* symbol = entry->symbol;

        if(strcmp(symbol->name, name) == 0
            && scope_is_child_of(scope, symbol->scope))
        {
            return symbol;
        }

        entry = entry->next;
    }

    return nullptr;
}

export VarSymbol* var_table_find_or_insert(Scope* scope, char* name)
{
    assert(name != nullptr);

    u64 index = hash_djb2(name) % VAR_TABLE_CAPACITY;
    VarTableEntry* entry = var_table.entries[index];

    while(entry != nullptr)
    {
        VarSymbol* symbol = entry->symbol;

        if(strcmp(symbol->name, name) == 0
            && scope_is_child_of(scope, symbol->scope))
        {
            return symbol;
        }

        entry = entry->next;
    }

    VarSymbol* symbol = malloc(sizeof(VarSymbol));
    symbol->scope = scope;
    symbol->name = name;

    VarTableEntry* new_entry = malloc(sizeof(VarTableEntry));
    new_entry->symbol = symbol;
    new_entry->next = var_table.entries[index];

    var_table.entries[index] = new_entry;

    return symbol;
}
