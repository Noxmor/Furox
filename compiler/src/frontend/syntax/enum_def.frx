import "../ast/enum_def.frx";
import "../ast/binary_expr.frx";
import "expr.frx";
import "int_literal.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../symbols/enum.frx";
import "../../core/list.frx";

namespace AST::EnumConstantDef
{
    EnumConstantDef* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        char* name = parser->token->identifier;

        Parser::eat(parser, TokenType::IDENTIFIER);

        mut Expr* value = nullptr;
        if(parser->token->type == TokenType::EQ)
        {
            Parser::eat(parser, TokenType::EQ);

            value = AST::Expr::parse(parser);
        }

        return new(&parser->arena, name, value);
    }
}

namespace AST::EnumDef
{
    export EnumDef* parse(Parser* parser, b8 exported)
    {
        frx::assert(parser != nullptr);

        SourceLocation start = Parser::current_location(parser);

        Parser::eat(parser, TokenType::KW_ENUM);

        char* name = parser->token->identifier;

        Parser::eat(parser, TokenType::IDENTIFIER);

        Parser::eat(parser, TokenType::COLON);

        mut TokenType type = TokenType::EOF;

        switch(parser->token->type)
        {
            case TokenType::KW_I8:
            {

            }
            case TokenType::KW_I16:
            {

            }
            case TokenType::KW_I32:
            {

            }
            case TokenType::KW_I64:
            {

            }
            case TokenType::KW_U8:
            {

            }
            case TokenType::KW_U16:
            {

            }
            case TokenType::KW_U32:
            {

            }
            case TokenType::KW_U64:
            {
                type = parser->token->type;

                Parser::eat(parser, parser->token->type);

                break;
            }
            default:
            {
                Parser::panic(parser);

                break;
            }
        }

        mut EnumDef* enum_def = new(&parser->arena,
            parser->current_scope, nullptr, name, type, exported);

        enum_def->is_redefinition = !enum_table_insert(&parser->enum_table,
            &enum_def->symbol);

        Parser::eat(parser, TokenType::LBRACE);

        while(Parser::loop_until(parser, TokenType::RBRACE))
        {
            EnumConstantDef* constant = AST::EnumConstantDef::parse(parser);

            AST::EnumDef::add_constant(&parser->arena, enum_def, constant);

            if(parser->token->type == TokenType::COMMA)
            {
                Parser::eat(parser, TokenType::COMMA);
            }
            else
            {
                break;
            }
        }

        enum_def->range.start = start;
        enum_def->range.end = Parser::current_location(parser);

        Parser::eat(parser, TokenType::RBRACE);

        return enum_def;
    }
}
