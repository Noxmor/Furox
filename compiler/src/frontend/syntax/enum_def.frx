export struct ASTEnumConstantDef
{
    char* name;
    AST* value;
}

ASTEnumConstantDef* make_enum_constant_def(Arena* arena, char* name, AST* value)
{
    assert(name != nullptr);

    ASTEnumConstantDef* constant = arena_alloc(arena, sizeof(ASTEnumConstantDef));

    constant->name = name;
    constant->value = value;

    return constant;
}

ASTEnumConstantDef* parse_enum_constant(Parser* parser)
{
    assert(parser != nullptr);

    char* name = parser->token->identifier;

    parser_eat(parser, TOKEN_TYPE_IDENTIFIER);

    AST* value = nullptr;
    if(parser->token->type == TOKEN_TYPE_EQ)
    {
        parser_eat(parser, TOKEN_TYPE_EQ);

        value = parse_expr(parser);
    }

    return make_enum_constant_def(&parser->arena, name, value);
}

export struct ASTEnumDef
{
    EnumSymbol* symbol;

    TokenType type;

    Namespace* ns;
    char* name;

    List constants;
}

void enum_def_add_constant(Arena* arena, ASTEnumDef* enum_def,
    ASTEnumConstantDef* constant)
{
    assert(enum_def != nullptr);

    assert(constant != nullptr);

    if(constant->value == nullptr)
    {
        AST* new_value = nullptr;

        if(list_size(&enum_def->constants) == 0)
        {
            ASTIntLiteral* literal = make_int_literal(arena, 0);
            new_value = make_ast(arena, AST_TYPE_INT_LITERAL, literal);
        }
        else
        {
            ASTIntLiteral* literal = make_int_literal(arena, 1);

            ASTEnumConstantDef* last_constant = list_get(&enum_def->constants,
                list_size(&enum_def->constants) - 1);

            AST* left = last_constant->value;
            AST* right = make_ast(arena, AST_TYPE_INT_LITERAL, literal);

            ASTBinaryExpr* expr = make_binary_expr(arena, TOKEN_TYPE_PLUS,
                left, right);

            new_value = make_ast(arena, AST_TYPE_BINARY_EXPR, expr);
        }

        constant->value = new_value;
    }

    list_push(&enum_def->constants, constant);
}

export ASTEnumDef* make_enum_def(Arena* arena, Namespace* ns, char* name,
    TokenType type)
{
    assert(name != nullptr);

    assert(type != TOKEN_TYPE_ERROR);

    ASTEnumDef* enum_def = arena_alloc(arena, sizeof(ASTEnumDef));

    enum_def->type = type;
    enum_def->ns = ns;
    enum_def->name = name;
    list_init(&enum_def->constants);

    enum_def->symbol = enum_table_insert(enum_def);

    return enum_def;
}

export ASTEnumDef* parse_enum_def(Parser* parser)
{
    assert(parser != nullptr);

    parser_eat(parser, TOKEN_TYPE_KW_ENUM);

    char* name = parser->token->identifier;


    parser_eat(parser, TOKEN_TYPE_IDENTIFIER);

    parser_eat(parser, TOKEN_TYPE_COLON);

    TokenType type = TOKEN_TYPE_ERROR;

    switch(parser->token->type)
    {
        case TOKEN_TYPE_KW_I8:
        {

        }
        case TOKEN_TYPE_KW_I16:
        {

        }
        case TOKEN_TYPE_KW_I32:
        {

        }
        case TOKEN_TYPE_KW_I64:
        {

        }
        case TOKEN_TYPE_KW_U8:
        {

        }
        case TOKEN_TYPE_KW_U16:
        {

        }
        case TOKEN_TYPE_KW_U32:
        {

        }
        case TOKEN_TYPE_KW_U64:
        {
            type = parser->token->type;

            parser_eat(parser, parser->token->type);

            break;
        }
        default:
        {
            parser_panic(parser);

            break;
        }
    }

    ASTEnumDef* enum_def = make_enum_def(&parser->arena,
        parser->current_namespace, name, type);

    parser_eat(parser, TOKEN_TYPE_LBRACE);

    while(parser->token->type != TOKEN_TYPE_RBRACE)
    {
        ASTEnumConstantDef* constant = parse_enum_constant(parser);

        enum_def_add_constant(&parser->arena, enum_def, constant);

        if(parser->token->type == TOKEN_TYPE_COMMA)
        {
            parser_eat(parser, TOKEN_TYPE_COMMA);
        }
        else
        {
            break;
        }
    }

    parser_eat(parser, TOKEN_TYPE_RBRACE);

    return enum_def;
}

export void print_enum_def(ASTEnumDef* enum_def, FILE* file, usize depth)
{
    assert(enum_def != nullptr);

    assert(file != nullptr);

    print_ast_depth(file, depth);

    fprintf(file, "%s (%s)\n", ast_type_to_str(AST_TYPE_ENUM_DEF),
        enum_def->name);

    usize i;
    for(i = 0; i < list_size(&enum_def->constants); i = i + 1)
    {
        ASTEnumConstantDef* constant = list_get(&enum_def->constants, i);

        print_ast_depth(file, depth + 1);
        fprintf(file, "%s\n", constant->name);
    }
}
