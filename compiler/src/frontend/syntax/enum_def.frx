import "../core/parser.frx";
import "../symbols/enum.frx";

export struct ASTEnumConstantDef
{
    char* name;
    AST* value;
}

ASTEnumConstantDef* make_enum_constant_def(Arena* arena, char* name, AST* value)
{
    assert(name != nullptr);

    ASTEnumConstantDef* constant = arena_alloc(arena, sizeof(ASTEnumConstantDef));

    constant->name = name;
    constant->value = value;

    return constant;
}

ASTEnumConstantDef* parse_enum_constant(Parser* parser)
{
    assert(parser != nullptr);

    char* name = parser->token->identifier;

    parser_eat(parser, TOKEN_TYPE_IDENTIFIER);

    AST* value = nullptr;
    if(parser->token->type == TOKEN_TYPE_EQ)
    {
        parser_eat(parser, TOKEN_TYPE_EQ);

        value = parse_expr(parser);
    }

    return make_enum_constant_def(&parser->arena, name, value);
}

export struct ASTEnumDef
{
    SourceRange range;

    EnumSymbol symbol;
}

void enum_def_add_constant(Arena* arena, ASTEnumDef* enum_def,
    ASTEnumConstantDef* constant)
{
    assert(enum_def != nullptr);

    assert(constant != nullptr);

    List* constants = &enum_def->symbol.constants;

    if(constant->value == nullptr)
    {
        AST* new_value = nullptr;

        if(list_size(constants) == 0)
        {
            ASTIntLiteral* literal = make_int_literal(arena, 0);
            new_value = make_ast(arena, AST_TYPE_INT_LITERAL, literal);
        }
        else
        {
            ASTIntLiteral* literal = make_int_literal(arena, 1);

            ASTEnumConstantDef* last_constant = list_get(constants,
                list_size(constants) - 1);

            AST* left = last_constant->value;
            AST* right = make_ast(arena, AST_TYPE_INT_LITERAL, literal);

            ASTBinaryExpr* expr = make_binary_expr(arena, TOKEN_TYPE_PLUS,
                left, right);

            new_value = make_ast(arena, AST_TYPE_BINARY_EXPR, expr);
        }

        constant->value = new_value;
    }

    list_push(constants, constant);
}

export ASTEnumDef* make_enum_def(Arena* arena, Scope* scope, Namespace* ns,
    char* name, TokenType type, b8 exported)
{
    ASTEnumDef* enum_def = arena_alloc(arena, sizeof(ASTEnumDef));

    enum_symbol_init(&enum_def->symbol, type, scope, ns, name, exported);

    return enum_def;
}

export ASTEnumDef* parse_enum_def(Parser* parser, b8 exported)
{
    assert(parser != nullptr);

    SourceLocation start = parser_current_location(parser);

    parser_eat(parser, TOKEN_TYPE_KW_ENUM);

    char* name = parser->token->identifier;

    parser_eat(parser, TOKEN_TYPE_IDENTIFIER);

    parser_eat(parser, TOKEN_TYPE_COLON);

    TokenType type = TOKEN_TYPE_ERROR;

    switch(parser->token->type)
    {
        case TOKEN_TYPE_KW_I8:
        {

        }
        case TOKEN_TYPE_KW_I16:
        {

        }
        case TOKEN_TYPE_KW_I32:
        {

        }
        case TOKEN_TYPE_KW_I64:
        {

        }
        case TOKEN_TYPE_KW_U8:
        {

        }
        case TOKEN_TYPE_KW_U16:
        {

        }
        case TOKEN_TYPE_KW_U32:
        {

        }
        case TOKEN_TYPE_KW_U64:
        {
            type = parser->token->type;

            parser_eat(parser, parser->token->type);

            break;
        }
        default:
        {
            parser_panic(parser);

            break;
        }
    }

    ASTEnumDef* enum_def = make_enum_def(&parser->arena,
        parser->current_scope, parser->current_namespace, name, type, exported);

    enum_table_insert(&parser->enum_table, &enum_def->symbol);

    parser_eat(parser, TOKEN_TYPE_LBRACE);

    while(parser->token->type != TOKEN_TYPE_RBRACE)
    {
        ASTEnumConstantDef* constant = parse_enum_constant(parser);

        enum_def_add_constant(&parser->arena, enum_def, constant);

        if(parser->token->type == TOKEN_TYPE_COMMA)
        {
            parser_eat(parser, TOKEN_TYPE_COMMA);
        }
        else
        {
            break;
        }
    }

    enum_def->range.start = start;
    enum_def->range.end = parser_current_location(parser);

    parser_eat(parser, TOKEN_TYPE_RBRACE);

    return enum_def;
}

export void print_enum_def(ASTEnumDef* enum_def, FILE* file, usize depth)
{
    assert(enum_def != nullptr);

    assert(file != nullptr);

    print_ast_depth(file, depth);

    fprintf(file, "%s (%s)\n", ast_type_to_str(AST_TYPE_ENUM_DEF),
        enum_def->symbol.name);

    usize i;
    for(i = 0; i < list_size(&enum_def->symbol.constants); i = i + 1)
    {
        ASTEnumConstantDef* constant = list_get(&enum_def->symbol.constants, i);

        print_ast_depth(file, depth + 1);
        fprintf(file, "%s\n", constant->name);
    }
}
