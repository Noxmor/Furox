export AST* parse_primary_expr(Parser* parser)
{
    assert(parser != nullptr);

    if(token_type_is_unary_operator(parser->token->type))
    {
        return make_ast(&parser->arena, AST_TYPE_UNARY_EXPR,
            parse_unary_expr(parser));
    }

    AST* primary_expr = nullptr;

    switch(parser->token->type)
    {
        case TOKEN_TYPE_IDENTIFIER:
        {
            Namespace* resolved_ns = parse_namespace_resolution(parser);

            Token* next = parser_peek(parser, 1);

            if(next->type == TOKEN_TYPE_LPAREN)
            {
                if(namespace_is_internal(resolved_ns))
                {
                    primary_expr = parse_internal_func_call(parser);
                }
                else
                {
                    primary_expr = make_ast(&parser->arena, AST_TYPE_FUNC_CALL,
                        parse_func_call(parser, resolved_ns));
                }
            }
            else if(resolved_ns == nullptr)
            {
                primary_expr = make_ast(&parser->arena,
                    AST_TYPE_VAR, parse_var(parser, nullptr));
            }
            else
            {
                primary_expr = make_ast(&parser->arena,
                    AST_TYPE_ENUM_CONSTANT_OR_GLOBAL_VAR,
                    parse_enum_constant_or_global_var(parser, resolved_ns));
            }

            break;
        }
        case TOKEN_TYPE_NAMESPACE_RESOLUTION:
        {
            Namespace* resolved_ns = parse_namespace_resolution(parser);

            primary_expr = make_ast(&parser->arena, AST_TYPE_FUNC_CALL,
                parse_func_call(parser, resolved_ns));

            break;
        }
        case TOKEN_TYPE_KW_NULLPTR:
        {
            parser_eat(parser, TOKEN_TYPE_KW_NULLPTR);

            primary_expr = make_ast(&parser->arena, AST_TYPE_INT_LITERAL,
                make_int_literal(&parser->arena, 0));

            break;
        }
        case TOKEN_TYPE_KW_TRUE:
        {
            parser_eat(parser, TOKEN_TYPE_KW_TRUE);

            primary_expr = make_ast(&parser->arena, AST_TYPE_INT_LITERAL,
                make_int_literal(&parser->arena, 1));

            break;
        }
        case TOKEN_TYPE_KW_FALSE:
        {
            parser_eat(parser, TOKEN_TYPE_KW_FALSE);

            primary_expr = make_ast(&parser->arena, AST_TYPE_INT_LITERAL,
                make_int_literal(&parser->arena, 0));

            break;
        }
        case TOKEN_TYPE_FLOAT_LITERAL:
        {
            primary_expr = make_ast(&parser->arena, AST_TYPE_FLOAT_LITERAL,
                parse_float_literal(parser));

            break;
        }
        case TOKEN_TYPE_INT_LITERAL:
        {
            primary_expr = make_ast(&parser->arena, AST_TYPE_INT_LITERAL,
                parse_int_literal(parser));

            break;
        }
        case TOKEN_TYPE_CHAR_LITERAL:
        {
            primary_expr = make_ast(&parser->arena, AST_TYPE_CHAR_LITERAL,
                parse_char_literal(parser));

            break;
        }
        case TOKEN_TYPE_STRING_LITERAL:
        {
            primary_expr = make_ast(&parser->arena, AST_TYPE_STRING_LITERAL,
                parse_string_literal(parser));

            break;
        }
        default:
        {
            parser_panic(parser);

            break;
        }
    }

    return primary_expr;
}

export AST* parse_expr(Parser* parser)
{
    assert(parser != nullptr);

    AST* expr = nullptr;

    if(parser->token->type == TOKEN_TYPE_LPAREN)
    {
        parser_eat(parser, TOKEN_TYPE_LPAREN);

        expr = parse_expr(parser);
        if(expr->type == AST_TYPE_BINARY_EXPR)
        {
            ASTBinaryExpr* binary_expr = expr->node;
            binary_expr->precedence = PRECEDENCE_MAX;
        }

        parser_eat(parser, TOKEN_TYPE_RPAREN);
    }
    else
    {
        expr = parse_primary_expr(parser);
    }

    if(!token_type_is_binary_operator(parser->token->type))
    {
        return expr;
    }

    TokenType operator = parser->token->type;

    parser_eat(parser, parser->token->type);

    AST* left = expr;
    AST* right = parse_expr(parser);

    if(operator == TOKEN_TYPE_LBRACKET)
    {
        parser_eat(parser, TOKEN_TYPE_RBRACKET);
    }

    ASTBinaryExpr* binary_expr = make_binary_expr(&parser->arena, operator,
        left, right);

    //TODO: Handle operator precedence

    return make_ast(&parser->arena, AST_TYPE_BINARY_EXPR, binary_expr);
}
