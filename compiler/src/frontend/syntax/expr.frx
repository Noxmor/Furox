export import "../ast/expr.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/source_location.frx";
import "../core/token.frx";
import "../ast/binary_expr.frx";
import "char_literal.frx";
import "error.frx";
import "float_literal.frx";
import "func_call.frx";
import "int_literal.frx";
import "internal_func_call.frx";
import "namespace_resolution.frx";
import "string_literal.frx";
import "../ast/unary_expr.frx";
import "unresolved_name.frx";
import "unresolved_namespaced_name.frx";

namespace AST::Expr
{
    export Expr* parse_primary(Parser* parser)
    {
        frx::assert(parser != nullptr);

        mut Expr* primary_expr = nullptr;

        switch(parser->token->type)
        {
            case TokenType::IDENTIFIER:
            {
                SourceLocation start = parser_current_location(parser);
                core::Namespace* resolved_ns = AST::NamespaceResolution::parse(parser);

                Token* next = parser_peek(parser, 1);

                if(next->type == TokenType::LPAREN)
                {
                    if(namespace_is_internal(resolved_ns))
                    {
                        primary_expr = from_internal_func_call(&parser->arena,
                            AST::InternalFuncCall::parse(parser));
                    }
                    else
                    {
                        primary_expr = from_func_call(&parser->arena,
                            AST::FuncCall::parse(parser, resolved_ns));
                    }
                }
                else if(resolved_ns == nullptr)
                {
                    primary_expr = from_unresolved_name(&parser->arena,
                        AST::UnresolvedName::parse(parser));
                }
                else
                {
                    primary_expr = from_unresolved_namespaced_name(&parser->arena,
                        AST::UnresolvedNamespacedName::parse(parser, resolved_ns, start));
                }

                break;
            }
            case TokenType::NAMESPACE_RESOLUTION:
            {
                core::Namespace* resolved_ns = AST::NamespaceResolution::parse(parser);

                primary_expr = from_func_call(&parser->arena,
                    AST::FuncCall::parse(parser, resolved_ns));

                break;
            }
            case TokenType::KW_NULLPTR:
            {
                parser_eat(parser, TokenType::KW_NULLPTR);

                primary_expr = from_int_literal(&parser->arena,
                    AST::IntLiteral::new(&parser->arena, 0));

                break;
            }
            case TokenType::KW_TRUE:
            {
                parser_eat(parser, TokenType::KW_TRUE);

                primary_expr = from_int_literal(&parser->arena,
                    AST::IntLiteral::new(&parser->arena, 1));

                break;
            }
            case TokenType::KW_FALSE:
            {
                parser_eat(parser, TokenType::KW_FALSE);

                primary_expr = from_int_literal(&parser->arena,
                    AST::IntLiteral::new(&parser->arena, 0));

                break;
            }
            case TokenType::FLOAT_LITERAL:
            {
                primary_expr = from_float_literal(&parser->arena,
                    AST::FloatLiteral::parse(parser));

                break;
            }
            case TokenType::INT_LITERAL:
            {
                primary_expr = from_int_literal(&parser->arena,
                    AST::IntLiteral::parse(parser));

                break;
            }
            case TokenType::CHAR_LITERAL:
            {
                primary_expr = from_char_literal(&parser->arena,
                    AST::CharLiteral::parse(parser));

                break;
            }
            case TokenType::STRING_LITERAL:
            {
                primary_expr = from_string_literal(&parser->arena,
                    AST::StringLiteral::parse(parser));

                break;
            }
            default:
            {
                primary_expr = from_error(&parser->arena,
                    AST::Error::parse(parser));

                break;
            }
        }

        return primary_expr;
    }

    export Expr* parse(Parser* parser)
    {
        return parse_with_precedence(parser, Precedence::MIN);
    }

    Expr* parse_with_precedence(Parser* parser, Precedence min_precedence)
    {
        frx::assert(parser != nullptr);

        mut Expr* expr = nullptr;

        if(parser->token->type == TokenType::LPAREN)
        {
            parser_eat(parser, TokenType::LPAREN);
            expr = parse(parser);
            parser_eat(parser, TokenType::RPAREN);
        }
        else if(token_type_is_prefix_operator(parser->token->type))
        {
            TokenType type = parser->token->type;

            parser_eat(parser, type);

            Operator operator = token_type_to_prefix_operator(type);
            Precedence precedence = operator_to_precedence(operator);
            UnaryExpr* unary_expr = AST::UnaryExpr::new(&parser->arena, type,
                operator, parse_with_precedence(parser, precedence));
            expr = from_unary_expr(&parser->arena, unary_expr);
        }
        else
        {
            expr = parse_primary(parser);
        }

        frx::assert(expr != nullptr);

        while(true)
        {
            TokenType type = parser->token->type;

            if(token_type_is_postfix_operator(type))
            {
                Operator operator = token_type_to_postfix_operator(type);
                Precedence precedence = operator_to_precedence(operator);
                if(precedence >= min_precedence)
                {
                    break;
                }

                parser_eat(parser, type);

                if(operator == Operator::ARRAY_SUBSCRIPT)
                {
                    Expr* index = parse(parser);
                    parser_eat(parser, TokenType::RBRACKET);

                    BinaryExpr* binary_expr = AST::BinaryExpr::new(&parser->arena,
                        type, operator, expr, index);
                    expr = from_binary_expr(&parser->arena, binary_expr);
                }
                else
                {
                    UnaryExpr* unary_expr = AST::UnaryExpr::new(&parser->arena, type,
                        operator, expr);
                    expr = from_unary_expr(&parser->arena, unary_expr);
                }

                continue;
            }
            else if(token_type_is_infix_operator(type))
            {
                Operator operator = token_type_to_infix_operator(type);
                Precedence precedence = operator_to_precedence(operator);
                if(precedence >= min_precedence)
                {
                    break;
                }

                parser_eat(parser, type);

                BinaryExpr* binary_expr = AST::BinaryExpr::new(&parser->arena, type,
                    operator, expr, parse_with_precedence(parser, precedence));
                expr = from_binary_expr(&parser->arena, binary_expr);

                continue;
            }

            break;
        }

        return expr;
    }
}
