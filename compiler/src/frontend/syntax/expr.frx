export import "../ast/expr.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/source_location.frx";
import "../core/token.frx";
import "../ast/binary_expr.frx";
import "char_literal.frx";
import "error.frx";
import "float_literal.frx";
import "func_call.frx";
import "int_literal.frx";
import "internal_func_call.frx";
import "namespace_resolution.frx";
import "string_literal.frx";
import "../ast/unary_expr.frx";
import "unresolved_identifier.frx";

export Expr* expr_parse_primary(Parser* parser)
{
    frx::assert(parser != nullptr);

    mut Expr* primary_expr = nullptr;

    NamespaceResolution* resolution = namespace_resolution_parse(parser);

    switch(parser->token->type)
    {
        case TokenType::IDENTIFIER:
            {
                SourceLocation start = parser_current_location(parser);

                Token* next = parser_peek(parser, 1);

                if(next->type == TokenType::LPAREN)
                {
                    if(namespace_is_internal(resolution->ns))
                    {
                        primary_expr = expr_from_internal_func_call(&parser->arena,
                                internal_func_call_parse(parser));
                    }
                    else
                    {
                        primary_expr = expr_from_func_call(&parser->arena,
                                func_call_parse(parser, resolution));
                    }
                }
                else
                {
                    primary_expr = expr_from_unresolved_identifier(&parser->arena,
                            unresolved_identifier_parse(parser, resolution, start));
                }

                break;
            }
        case TokenType::KW_NULLPTR:
            {
                parser_eat(parser, TokenType::KW_NULLPTR);

                primary_expr = expr_from_int_literal(&parser->arena,
                        int_literal_new(&parser->arena, 0));

                break;
            }
        case TokenType::KW_TRUE:
            {
                parser_eat(parser, TokenType::KW_TRUE);

                primary_expr = expr_from_int_literal(&parser->arena,
                        int_literal_new(&parser->arena, 1));

                break;
            }
        case TokenType::KW_FALSE:
            {
                parser_eat(parser, TokenType::KW_FALSE);

                primary_expr = expr_from_int_literal(&parser->arena,
                        int_literal_new(&parser->arena, 0));

                break;
            }
        case TokenType::FLOAT_LITERAL:
            {
                primary_expr = expr_from_float_literal(&parser->arena,
                        float_literal_parse(parser));

                break;
            }
        case TokenType::INT_LITERAL:
            {
                primary_expr = expr_from_int_literal(&parser->arena,
                        int_literal_parse(parser));

                break;
            }
        case TokenType::CHAR_LITERAL:
            {
                primary_expr = expr_from_char_literal(&parser->arena,
                        char_literal_parse(parser));

                break;
            }
        case TokenType::STRING_LITERAL:
            {
                primary_expr = expr_from_string_literal(&parser->arena,
                        string_literal_parse(parser));

                break;
            }
        default:
            {
                primary_expr = expr_from_error(&parser->arena,
                        error_parse(parser));

                break;
            }
    }

    return primary_expr;
}

export Expr* expr_parse(Parser* parser)
{
    return expr_parse_with_precedence(parser, Precedence::MIN);
}

Expr* expr_parse_with_precedence(Parser* parser, Precedence min_precedence)
{
    frx::assert(parser != nullptr);

    mut Expr* expr = nullptr;

    if(parser->token->type == TokenType::LPAREN)
    {
        parser_eat(parser, TokenType::LPAREN);
        expr = expr_parse(parser);
        parser_eat(parser, TokenType::RPAREN);
    }
    else if(token_type_is_prefix_operator(parser->token->type))
    {
        TokenType type = parser->token->type;

        parser_eat(parser, type);

        Operator operator = token_type_to_prefix_operator(type);
        Precedence precedence = operator_to_precedence(operator);
        UnaryExpr* unary_expr = unary_expr_new(&parser->arena, type,
                operator, expr_parse_with_precedence(parser, precedence));
        expr = expr_from_unary_expr(&parser->arena, unary_expr);
    }
    else
    {
        expr = expr_parse_primary(parser);
    }

    frx::assert(expr != nullptr);

    while(true)
    {
        TokenType type = parser->token->type;

        if(token_type_is_postfix_operator(type))
        {
            Operator operator = token_type_to_postfix_operator(type);
            Precedence precedence = operator_to_precedence(operator);
            if(precedence >= min_precedence)
            {
                break;
            }

            parser_eat(parser, type);

            if(operator == Operator::ARRAY_SUBSCRIPT)
            {
                Expr* index = expr_parse(parser);
                parser_eat(parser, TokenType::RBRACKET);

                BinaryExpr* binary_expr = binary_expr_new(&parser->arena,
                        type, operator, expr, index);
                expr = expr_from_binary_expr(&parser->arena, binary_expr);
            }
            else
            {
                UnaryExpr* unary_expr = unary_expr_new(&parser->arena, type,
                        operator, expr);
                expr = expr_from_unary_expr(&parser->arena, unary_expr);
            }

            continue;
        }
        else if(token_type_is_infix_operator(type))
        {
            Operator operator = token_type_to_infix_operator(type);
            Precedence precedence = operator_to_precedence(operator);
            if(precedence >= min_precedence)
            {
                break;
            }

            parser_eat(parser, type);

            BinaryExpr* binary_expr = binary_expr_new(&parser->arena, type,
                    operator, expr, expr_parse_with_precedence(parser, precedence));
            expr = expr_from_binary_expr(&parser->arena, binary_expr);

            continue;
        }

        break;
    }

    return expr;
}
