import "../core/ast.frx";
import "../core/parser.frx";

export AST* parse_primary_expr(Parser* parser)
{
    assert(parser != nullptr);

    AST* primary_expr = nullptr;

    switch(parser->token->type)
    {
        case TOKEN_TYPE_IDENTIFIER:
        {
            SourceLocation start = parser_current_location(parser);
            Namespace* resolved_ns = parse_namespace_resolution(parser);

            Token* next = parser_peek(parser, 1);

            if(next->type == TOKEN_TYPE_LPAREN)
            {
                if(namespace_is_internal(resolved_ns))
                {
                    primary_expr = parse_internal_func_call(parser);
                }
                else
                {
                    primary_expr = make_ast(&parser->arena, AST_TYPE_FUNC_CALL,
                        parse_func_call(parser, resolved_ns));
                }
            }
            else if(resolved_ns == nullptr)
            {
                primary_expr = make_ast(&parser->arena,
                    AST_TYPE_UNRESOLVED_NAME, parse_unresolved_name(parser));
            }
            else
            {
                primary_expr = make_ast(&parser->arena,
                    AST_TYPE_UNRESOLVED_NAMESPACED_NAME,
                    parse_unresolved_namespaced_name(parser, resolved_ns,
                    start));
            }

            break;
        }
        case TOKEN_TYPE_NAMESPACE_RESOLUTION:
        {
            Namespace* resolved_ns = parse_namespace_resolution(parser);

            primary_expr = make_ast(&parser->arena, AST_TYPE_FUNC_CALL,
                parse_func_call(parser, resolved_ns));

            break;
        }
        case TOKEN_TYPE_KW_NULLPTR:
        {
            parser_eat(parser, TOKEN_TYPE_KW_NULLPTR);

            primary_expr = make_ast(&parser->arena, AST_TYPE_INT_LITERAL,
                make_int_literal(&parser->arena, 0));

            break;
        }
        case TOKEN_TYPE_KW_TRUE:
        {
            parser_eat(parser, TOKEN_TYPE_KW_TRUE);

            primary_expr = make_ast(&parser->arena, AST_TYPE_INT_LITERAL,
                make_int_literal(&parser->arena, 1));

            break;
        }
        case TOKEN_TYPE_KW_FALSE:
        {
            parser_eat(parser, TOKEN_TYPE_KW_FALSE);

            primary_expr = make_ast(&parser->arena, AST_TYPE_INT_LITERAL,
                make_int_literal(&parser->arena, 0));

            break;
        }
        case TOKEN_TYPE_FLOAT_LITERAL:
        {
            primary_expr = make_ast(&parser->arena, AST_TYPE_FLOAT_LITERAL,
                parse_float_literal(parser));

            break;
        }
        case TOKEN_TYPE_INT_LITERAL:
        {
            primary_expr = make_ast(&parser->arena, AST_TYPE_INT_LITERAL,
                parse_int_literal(parser));

            break;
        }
        case TOKEN_TYPE_CHAR_LITERAL:
        {
            primary_expr = make_ast(&parser->arena, AST_TYPE_CHAR_LITERAL,
                parse_char_literal(parser));

            break;
        }
        case TOKEN_TYPE_STRING_LITERAL:
        {
            primary_expr = make_ast(&parser->arena, AST_TYPE_STRING_LITERAL,
                parse_string_literal(parser));

            break;
        }
        default:
        {
            primary_expr = make_ast(&parser->arena, AST_TYPE_ERROR,
                parse_error(parser));

            break;
        }
    }

    return primary_expr;
}

export AST* parse_expr(Parser* parser)
{
    return parse_expr_with_precedence(parser, PRECEDENCE_MIN);
}

export AST* parse_expr_with_precedence(Parser* parser,
    Precedence min_precedence)
{
    assert(parser != nullptr);

    AST* expr = nullptr;

    if(parser->token->type == TOKEN_TYPE_LPAREN)
    {
        parser_eat(parser, TOKEN_TYPE_LPAREN);
        expr = parse_expr(parser);
        parser_eat(parser, TOKEN_TYPE_RPAREN);
    }
    else if(token_type_is_prefix_operator(parser->token->type))
    {
        TokenType type = parser->token->type;

        parser_eat(parser, type);

        Operator operator = token_type_to_prefix_operator(type);
        Precedence precedence = operator_to_precedence(operator);
        ASTUnaryExpr* unary_expr = make_unary_expr(&parser->arena, type,
            operator, parse_expr_with_precedence(parser, precedence));
        expr = make_ast(&parser->arena, AST_TYPE_UNARY_EXPR, unary_expr);
    }
    else
    {
        expr = parse_primary_expr(parser);
    }

    assert(expr != nullptr);

    while(true)
    {
        TokenType type = parser->token->type;

        if(token_type_is_postfix_operator(type))
        {
            Operator operator = token_type_to_postfix_operator(type);
            Precedence precedence = operator_to_precedence(operator);
            if(precedence >= min_precedence)
            {
                break;
            }

            parser_eat(parser, type);

            if(operator == OP_ARRAY_SUBSCRIPT)
            {
                AST* index = parse_expr(parser);
                parser_eat(parser, TOKEN_TYPE_RBRACKET);

                ASTBinaryExpr* binary_expr = make_binary_expr(&parser->arena,
                    type, operator, expr, index);
                expr = make_ast(&parser->arena, AST_TYPE_BINARY_EXPR,
                    binary_expr);
            }
            else
            {
                ASTUnaryExpr* unary_expr = make_unary_expr(&parser->arena, type,
                    operator, expr);
                expr = make_ast(&parser->arena, AST_TYPE_UNARY_EXPR,
                    unary_expr);
            }

            continue;
        }
        else if(token_type_is_infix_operator(type))
        {
            Operator operator = token_type_to_infix_operator(type);
            Precedence precedence = operator_to_precedence(operator);
            if(precedence >= min_precedence)
            {
                break;
            }

            parser_eat(parser, type);

            ASTBinaryExpr* binary_expr = make_binary_expr(&parser->arena, type,
                operator, expr, parse_expr_with_precedence(parser, precedence));
            expr = make_ast(&parser->arena, AST_TYPE_BINARY_EXPR, binary_expr);

            continue;
        }

        break;
    }

    return expr;
}
