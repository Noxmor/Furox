export import "../ast/func_params.frx";
import "type_specifier.frx";
import "../../core/list.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../symbols/var.frx";

namespace AST::FuncParam
{
    FuncParam* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        mut b8 mutable = false;
        if(parser->token->type == TokenType::KW_MUT)
        {
            mutable = true;
            Parser::eat(parser, TokenType::KW_MUT);
        }

        TypeSpecifier* type = AST::TypeSpecifier::parse(parser);
        char* name = parser->token->identifier;

        Parser::eat(parser, TokenType::IDENTIFIER);

        mut FuncParam* param = new(&parser->arena, type, parser->current_scope,
            name, mutable);

        param->is_redefinition = !var_table_insert(&parser->var_table, &param->symbol);

        return param;
    }
}

namespace AST::FuncParams
{
    export FuncParams* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        mut FuncParams* func_params = new(&parser->arena);

        Parser::eat(parser, TokenType::LPAREN);

        while(Parser::loop_until(parser, TokenType::RPAREN))
        {
            if(List::size(&func_params->params) > 0)
            {
                Parser::eat(parser, TokenType::COMMA);

                if(parser->token->type == TokenType::ELLIPSIS)
                {
                    Parser::eat(parser, TokenType::ELLIPSIS);

                    func_params->variadic = true;

                    break;
                }
            }

            List::push(&func_params->params, AST::FuncParam::parse(parser));
        }

        Parser::eat(parser, TokenType::RPAREN);

        return func_params;
    }
}
