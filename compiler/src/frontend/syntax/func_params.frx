export import "../ast/func_params.frx";
import "type_specifier.frx";
import "../../core/list.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../symbols/var.frx";

FuncParam* func_param_parse(Parser* parser)
{
    frx::assert(parser != nullptr);

    mut b8 mutable = false;
    if(parser->token->type == TokenType::KW_MUT)
    {
        mutable = true;
        parser_eat(parser, TokenType::KW_MUT);
    }

    TypeSpecifier* type = type_specifier_parse(parser);
    char* name = parser->token->identifier;

    parser_eat(parser, TokenType::IDENTIFIER);

    mut FuncParam* param = func_param_new(&parser->arena, type, parser->current_scope,
            name, mutable);

    param->is_redefinition = !var_table_insert(&parser->var_table, &param->symbol);

    return param;
}

export FuncParams* func_params_parse(Parser* parser)
{
    frx::assert(parser != nullptr);

    mut FuncParams* func_params = func_params_new(&parser->arena);

    parser_eat(parser, TokenType::LPAREN);

    while(parser_loop_until(parser, TokenType::RPAREN))
    {
        if(list_size(&func_params->params) > 0)
        {
            parser_eat(parser, TokenType::COMMA);

            if(parser->token->type == TokenType::ELLIPSIS)
            {
                parser_eat(parser, TokenType::ELLIPSIS);

                func_params->variadic = true;

                break;
            }
        }

        list_push(&func_params->params, func_param_parse(parser));
    }

    parser_eat(parser, TokenType::RPAREN);

    return func_params;
}
