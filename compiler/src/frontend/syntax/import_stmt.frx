export import "../ast/import_stmt.frx";
import "std/libc.frx";
import "../core/parser.frx";
import "../core/string_table.frx";
import "../../core/config.frx";
import "../../core/main.frx";
import "../../core/parser_table.frx";

extern struct FILE;

extern
{
    i32 sprintf(mut char* str, char* format, ...);
}

namespace AST::ImportStmt
{
    export ImportStmt* parse(Parser* parser, b8 exported)
    {
        parser_eat(parser, TokenType::KW_IMPORT);

        mut char* filepath = parser->token->identifier;

        parser_eat(parser, TokenType::STRING_LITERAL);

        char* std_prefix = "std/";
        char* lib_prefix = "lib/";

        Config* config = get_config();
        mut Parser* imported_parser = nullptr;

        if(libc::strncmp(filepath, std_prefix, libc::strlen(std_prefix)) == 0)
        {
            char stdlib_path[1024];
            sprintf(stdlib_path, "%s/%s", config->stdlib_path, filepath + 4);
            filepath = string_table_insert(stdlib_path);

            compile(filepath);
            imported_parser = parser_table_find(filepath);
        }
        else if(libc::strncmp(filepath, lib_prefix, libc::strlen(lib_prefix)) == 0)
        {
            frx::assert(config->library_path != nullptr);

            char library_path[1024];
            sprintf(library_path, "%s/%s", config->library_path, filepath + 4);
            filepath = string_table_insert(library_path);

            compile(filepath);
            imported_parser = parser_table_find(filepath);
        }
        else
        {
            imported_parser = parser_compile(parser, filepath);
        }

        ImportStmt* import_stmt = new(&parser->arena, imported_parser, filepath,
            exported);

        parser_eat(parser, TokenType::SEMICOLON);

        return import_stmt;
    }
}
