export import "../ast/internal_func_call.frx";
import "std/libc.frx";
import "expr.frx";
import "namespace_resolution.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../symbols/enum.frx";
import "../symbols/struct.frx";

namespace AST::Assert
{
    Assert* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        SourceLocation start = Parser::current_location(parser);

        Expr* expr = AST::Expr::parse(parser);
        mut Assert* assert_node = new(&parser->arena, Parser::source_file(parser), expr);

        SourceLocation end = Parser::current_location(parser);

        assert_node->range.start = start;
        assert_node->range.end = end;

        return assert_node;
    }
}

namespace AST::Sizeof
{
    Sizeof* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        if(TokenType::is_primitive(parser->token->type))
        {
            TokenType type = parser->token->type;

            Parser::eat(parser, parser->token->type);

            return new(&parser->arena, nullptr, nullptr, type, parser->current_scope);
        }
        else
        {
            Namespace* ns = AST::NamespaceResolution::parse(parser);
            char* name = parser->token->identifier;

            Parser::eat(parser, TokenType::IDENTIFIER);

            return new(&parser->arena, ns, name, TokenType::ERROR, parser->current_scope);
        }
    }
}

namespace AST::EnumCount
{
    EnumCount* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        Namespace* ns = AST::NamespaceResolution::parse(parser);
        char* name = parser->token->identifier;

        Parser::eat(parser, TokenType::IDENTIFIER);

        return new(&parser->arena, ns, name, parser->current_scope);
    }
}

namespace AST::InternalFuncCall
{
    export InternalFuncCall* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        mut InternalFuncCall* internal_func_call = nullptr;

        char* name = parser->token->identifier;

        Parser::eat(parser, TokenType::IDENTIFIER);

        Parser::eat(parser, TokenType::LPAREN);

        if(libc::strcmp(name, "assert") == 0)
        {
            internal_func_call = from_assert(&parser->arena, AST::Assert::parse(parser));
        }
        else if(libc::strcmp(name, "sizeof") == 0)
        {
            internal_func_call = from_sizeof(&parser->arena, AST::Sizeof::parse(parser));
        }
        else if(libc::strcmp(name, "enum_count") == 0)
        {
            internal_func_call = from_enum_count(&parser->arena, AST::EnumCount::parse(parser));
        }

        Parser::eat(parser, TokenType::RPAREN);

        return internal_func_call;
    }
}
