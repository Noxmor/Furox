export import "../ast/internal_func_call.frx";
import "std/libc.frx";
import "expr.frx";
import "namespace_resolution.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../symbols/enum.frx";
import "../symbols/struct.frx";

Assert* assert_parse(Parser* parser)
{
    frx::assert(parser != nullptr);

    SourceLocation start = parser_current_location(parser);

    Expr* expr = expr_parse(parser);
    mut Assert* assert_node = assert_new(&parser->arena, parser_source_file(parser), expr);

    SourceLocation end = parser_current_location(parser);

    assert_node->range.start = start;
    assert_node->range.end = end;

    return assert_node;
}

Sizeof* sizeof_parse(Parser* parser)
{
    frx::assert(parser != nullptr);

    NamespaceResolution* resolution = namespace_resolution_parse(parser);

    if(token_type_is_primitive(parser->token->type))
    {
        TokenType type = parser->token->type;

        parser_eat(parser, parser->token->type);

        return sizeof_new(&parser->arena, resolution, nullptr, type, parser->current_scope);
    }
    else
    {
        char* name = parser->token->identifier;

        parser_eat(parser, TokenType::IDENTIFIER);

        return sizeof_new(&parser->arena, resolution, name, TokenType::EOF, parser->current_scope);
    }
}

EnumCount* enum_count_parse(Parser* parser)
{
    frx::assert(parser != nullptr);

    NamespaceResolution* resolution = namespace_resolution_parse(parser);
    char* name = parser->token->identifier;

    parser_eat(parser, TokenType::IDENTIFIER);

    return enum_count_new(&parser->arena, resolution, name, parser->current_scope);
}

export InternalFuncCall* internal_func_call_parse(Parser* parser)
{
    frx::assert(parser != nullptr);

    mut InternalFuncCall* internal_func_call = nullptr;

    char* name = parser->token->identifier;

    parser_eat(parser, TokenType::IDENTIFIER);

    parser_eat(parser, TokenType::LPAREN);

    if(libc_strcmp(name, "assert") == 0)
    {
        internal_func_call = internal_func_call_from_assert(&parser->arena, assert_parse(parser));
    }
    else if(libc_strcmp(name, "sizeof") == 0)
    {
        internal_func_call = internal_func_call_from_sizeof(&parser->arena, sizeof_parse(parser));
    }
    else if(libc_strcmp(name, "enum_count") == 0)
    {
        internal_func_call = internal_func_call_from_enum_count(&parser->arena, enum_count_parse(parser));
    }

    parser_eat(parser, TokenType::RPAREN);

    return internal_func_call;
}
