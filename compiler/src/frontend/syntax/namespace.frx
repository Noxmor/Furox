export import "../ast/namespace.frx";
import "namespace_scope.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../../core/list.frx";

namespace AST::Namespace
{
    export Namespace* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        core::Namespace* old_namespace = parser->current_namespace;

        Parser::eat(parser, TokenType::KW_NAMESPACE);

        Parser::push_namespace(parser, parser->token->identifier);

        Parser::eat(parser, TokenType::IDENTIFIER);

        Namespace* namespace_root = new(&parser->arena, parser->current_namespace);

        mut Namespace* current_namespace = namespace_root;

        while(parser->token->type == TokenType::NAMESPACE_RESOLUTION)
        {
            Parser::eat(parser, TokenType::NAMESPACE_RESOLUTION);

            Parser::push_namespace(parser, parser->token->identifier);

            Parser::eat(parser, TokenType::IDENTIFIER);

            Namespace* child_namespace = new(&parser->arena, parser->current_namespace);

            NamespaceScope* namespace_scope = AST::NamespaceScope::from_namespace(&parser->arena, child_namespace);

            List::push(&current_namespace->namespace_scope, namespace_scope);

            current_namespace = child_namespace;
        }

        Parser::eat(parser, TokenType::LBRACE);

        Parser::push_scope(parser);

        while(Parser::loop_until(parser, TokenType::RBRACE))
        {
            AST::NamespaceScope* child = AST::NamespaceScope::parse(parser);
            List::push(&current_namespace->namespace_scope, child);
        }

        Parser::eat(parser, TokenType::RBRACE);

        pop_back_namespace_until(parser, old_namespace);
        Parser::pop_scope(parser);

        return namespace_root;
    }
}

void pop_back_namespace_until(Parser* parser, core::Namespace* old_namespace)
{
    frx::assert(parser != nullptr);

    while(parser->current_namespace != old_namespace)
    {
        Parser::pop_namespace(parser);
    }
}
