export import "../ast/namespace.frx";
import "namespace_scope.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../../core/list.frx";

namespace AST::Namespace
{
    export Namespace* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        core::Namespace* old_namespace = parser->current_namespace;

        parser_eat(parser, TokenType::KW_NAMESPACE);

        parser_push_namespace(parser, parser->token->identifier);

        parser_eat(parser, TokenType::IDENTIFIER);

        Namespace* namespace_root = new(&parser->arena, parser->current_namespace);

        mut Namespace* current_namespace = namespace_root;

        while(parser->token->type == TokenType::NAMESPACE_RESOLUTION)
        {
            parser_eat(parser, TokenType::NAMESPACE_RESOLUTION);

            parser_push_namespace(parser, parser->token->identifier);

            parser_eat(parser, TokenType::IDENTIFIER);

            Namespace* child_namespace = new(&parser->arena, parser->current_namespace);

            NamespaceScope* namespace_scope = AST::NamespaceScope::from_namespace(&parser->arena, child_namespace);

            list_push(&current_namespace->namespace_scope, namespace_scope);

            current_namespace = child_namespace;
        }

        parser_eat(parser, TokenType::LBRACE);

        parser_push_scope(parser);

        while(parser_loop_until(parser, TokenType::RBRACE))
        {
            AST::NamespaceScope* child = AST::NamespaceScope::parse(parser);
            list_push(&current_namespace->namespace_scope, child);
        }

        parser_eat(parser, TokenType::RBRACE);

        pop_back_namespace_until(parser, old_namespace);
        parser_pop_scope(parser);

        return namespace_root;
    }
}

void pop_back_namespace_until(Parser* parser, core::Namespace* old_namespace)
{
    frx::assert(parser != nullptr);

    while(parser->current_namespace != old_namespace)
    {
        parser_pop_namespace(parser);
    }
}
