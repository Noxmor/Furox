import "../core/parser.frx";
import "../../core/list.frx";

export struct ASTScope
{
    SourceRange range;

    List stmts;
}

export ASTScope* make_scope(Arena* arena)
{
    ASTScope* scope = arena_alloc(arena, sizeof(ASTScope));

    list_init(&scope->stmts);

    return scope;
}

export ASTScope* parse_scope(Parser* parser)
{
    assert(parser != nullptr);

    SourceLocation start = parser_current_location(parser);

    parser_eat(parser, TOKEN_TYPE_LBRACE);

    parser_push_scope(parser);

    usize pushed_scopes = 1;

    ASTScope* scope = make_scope(&parser->arena);

    while(parser->token->type != TOKEN_TYPE_RBRACE)
    {
        switch(parser->token->type)
        {
            case TOKEN_TYPE_LBRACE:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_SCOPE, parse_scope(parser)));

                parser_push_scope(parser);
                pushed_scopes = pushed_scopes + 1;

                break;
            }
            case TOKEN_TYPE_KW_BREAK:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_BREAK_STMT, parse_break_stmt(parser)));

                break;
            }
            case TOKEN_TYPE_KW_CONTINUE:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_CONTINUE_STMT, parse_continue_stmt(parser)));

                break;
            }
            case TOKEN_TYPE_KW_RETURN:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_RETURN_STMT, parse_return_stmt(parser)));

                break;
            }
            case TOKEN_TYPE_KW_IF:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_IF_STMT, parse_if_stmt(parser)));

                parser_push_scope(parser);
                pushed_scopes = pushed_scopes + 1;

                break;
            }
            case TOKEN_TYPE_KW_FOR:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_FOR_LOOP, parse_for_loop(parser)));

                parser_push_scope(parser);
                pushed_scopes = pushed_scopes + 1;

                break;
            }
            case TOKEN_TYPE_KW_WHILE:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_WHILE_LOOP, parse_while_loop(parser)));

                parser_push_scope(parser);
                pushed_scopes = pushed_scopes + 1;

                break;
            }
            case TOKEN_TYPE_KW_DO:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_DO_WHILE_LOOP, parse_do_while_loop(parser)));

                parser_push_scope(parser);
                pushed_scopes = pushed_scopes + 1;

                break;
            }
            case TOKEN_TYPE_KW_U8:
            {

            }
            case TOKEN_TYPE_KW_U16:
            {

            }
            case TOKEN_TYPE_KW_U32:
            {

            }
            case TOKEN_TYPE_KW_U64:
            {

            }
            case TOKEN_TYPE_KW_USIZE:
            {

            }
            case TOKEN_TYPE_KW_I8:
            {

            }
            case TOKEN_TYPE_KW_I16:
            {

            }
            case TOKEN_TYPE_KW_I32:
            {

            }
            case TOKEN_TYPE_KW_I64:
            {

            }
            case TOKEN_TYPE_KW_ISIZE:
            {

            }
            case TOKEN_TYPE_KW_B8:
            {

            }
            case TOKEN_TYPE_KW_B16:
            {

            }
            case TOKEN_TYPE_KW_B32:
            {

            }
            case TOKEN_TYPE_KW_B64:
            {

            }
            case TOKEN_TYPE_KW_CHAR:
            {

            }
            case TOKEN_TYPE_KW_F32:
            {

            }
            case TOKEN_TYPE_KW_F64:
            {

            }
            case TOKEN_TYPE_KW_VOID:
            {
                ASTTypeSpecifier* type = parse_type_specifier(parser);
                list_push(&scope->stmts, parse_var_decl_or_def(parser, type,
                    false));

                break;
            }
            case TOKEN_TYPE_IDENTIFIER:
            {
                Namespace* resolved_ns = parse_namespace_resolution(parser);

                Token* next = parser_peek(parser, 1);
                if(next->type == TOKEN_TYPE_STAR
                    || next->type == TOKEN_TYPE_IDENTIFIER)
                {
                    ASTTypeSpecifier* type = parse_type_specifier(parser);
                    type->ns = resolved_ns;

                    list_push(&scope->stmts, parse_var_decl_or_def(parser, type,
                        false));
                }
                else
                {
                    ASTExprStmt* expr_stmt = parse_expr_stmt(parser);
                    AST* expr = expr_stmt->expr;

                    switch(expr->type)
                    {
                        case AST_TYPE_FUNC_CALL:
                        {
                            ASTFuncCall* func_call = expr->node;
                            func_call->ns = resolved_ns;

                            break;
                        }
                        case AST_TYPE_ENUM_CONSTANT_OR_GLOBAL_VAR:
                        {
                            ASTEnumConstantOrGlobalVar* enum_constant_or_global_var
                                = expr->node;

                            enum_constant_or_global_var->ns = resolved_ns;

                            break;
                        }
                    }

                    list_push(&scope->stmts, make_ast(&parser->arena,
                        AST_TYPE_EXPR_STMT, expr_stmt));
                }

                break;
            }
            case TOKEN_TYPE_KW_MUT:
            {
                parser_eat(parser, TOKEN_TYPE_KW_MUT);

                ASTTypeSpecifier* type = parse_type_specifier(parser);
                list_push(&scope->stmts, parse_var_decl_or_def(parser, type,
                    true));

                break;
            }
            default:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_EXPR_STMT, parse_expr_stmt(parser)));

                break;
            }
        }
    }

    scope->range.start = start;
    scope->range.end = parser_current_location(parser);

    parser_eat(parser, TOKEN_TYPE_RBRACE);

    while(pushed_scopes > 0)
    {
        parser_pop_scope(parser);
        pushed_scopes = pushed_scopes - 1;
    }

    return scope;
}

export void print_scope(ASTScope* scope, FILE* file, usize depth)
{
    assert(scope != nullptr);

    assert(file != nullptr);

    print_ast_depth(file, depth);

    fprintf(file, "%s\n", ast_type_to_str(AST_TYPE_SCOPE));

    usize i;
    for(i = 0; i < list_size(&scope->stmts); i = i + 1)
    {
        AST* stmt = list_get(&scope->stmts, i);
        print_ast(stmt, file, depth + 1);
    }
}
