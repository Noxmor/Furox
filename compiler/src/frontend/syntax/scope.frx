import "std/libc.frx";
export import "../ast/scope.frx";
import "../ast/expr.frx";
import "break_stmt.frx";
import "continue_stmt.frx";
import "do_while_loop.frx";
import "expr.frx";
import "expr_stmt.frx";
import "for_loop.frx";
import "func_call.frx";
import "if_stmt.frx";
import "namespace_resolution.frx";
import "return_stmt.frx";
import "switch_stmt.frx";
import "type_specifier.frx";
import "unresolved_identifier.frx";
import "var_decl.frx";
import "var_decl_or_def.frx";
import "var_def.frx";
import "while_loop.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../../core/list.frx";

export Scope* scope_parse(Parser* parser)
{
    frx::assert(parser != nullptr);

    SourceLocation start = parser_current_location(parser);

    parser_eat(parser, TokenType::LBRACE);

    parser_push_scope(parser);

    mut usize pushed_scopes = 1;

    mut Scope* scope = scope_new(&parser->arena);

    while(parser_loop_until(parser, TokenType::RBRACE))
    {
        switch(parser->token->type)
        {
            case TokenType::LBRACE:
                {
                    scope_add_stmt(scope, stmt_from_scope(&parser->arena, scope_parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
            case TokenType::KW_BREAK:
                {
                    scope_add_stmt(scope, stmt_from_break_stmt(&parser->arena, break_stmt_parse(parser)));

                    break;
                }
            case TokenType::KW_CONTINUE:
                {
                    scope_add_stmt(scope, stmt_from_continue_stmt(&parser->arena, continue_stmt_parse(parser)));

                    break;
                }
            case TokenType::KW_RETURN:
                {
                    scope_add_stmt(scope, stmt_from_return_stmt(&parser->arena, return_stmt_parse(parser)));

                    break;
                }
            case TokenType::KW_IF:
                {
                    scope_add_stmt(scope, stmt_from_if_stmt(&parser->arena, if_stmt_parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
            case TokenType::KW_FOR:
                {
                    scope_add_stmt(scope, stmt_from_for_loop(&parser->arena, for_loop_parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
            case TokenType::KW_WHILE:
                {
                    scope_add_stmt(scope, stmt_from_while_loop(&parser->arena, while_loop_parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
            case TokenType::KW_DO:
                {
                    scope_add_stmt(scope, stmt_from_do_while_loop(&parser->arena, do_while_loop_parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
            case TokenType::KW_SWITCH:
                {
                    scope_add_stmt(scope, stmt_from_switch_stmt(&parser->arena, switch_stmt_parse(parser)));

                    break;
                }
            case TokenType::KW_U8:
                {

                }
            case TokenType::KW_U16:
                {

                }
            case TokenType::KW_U32:
                {

                }
            case TokenType::KW_U64:
                {

                }
            case TokenType::KW_USIZE:
                {

                }
            case TokenType::KW_I8:
                {

                }
            case TokenType::KW_I16:
                {

                }
            case TokenType::KW_I32:
                {

                }
            case TokenType::KW_I64:
                {

                }
            case TokenType::KW_ISIZE:
                {

                }
            case TokenType::KW_B8:
                {

                }
            case TokenType::KW_B16:
                {

                }
            case TokenType::KW_B32:
                {

                }
            case TokenType::KW_B64:
                {

                }
            case TokenType::KW_CHAR:
                {

                }
            case TokenType::KW_F32:
                {

                }
            case TokenType::KW_F64:
                {

                }
            case TokenType::KW_VOID:
                {
                    TypeSpecifier* type = type_specifier_parse(parser);
                    scope_add_stmt(scope, var_decl_or_def_parse(parser, type, false));

                    break;
                }
            case TokenType::IDENTIFIER:
                {
                    mut NamespaceResolution* resolution = nullptr;

                    if(parser->token->type != TokenType::IDENTIFIER ||
                            libc_strcmp(parser->token->identifier, "frx") != 0)
                    {
                        resolution = namespace_resolution_parse(parser);
                    }

                    Token* next = parser_peek(parser, 1);
                    if((next->type == TokenType::STAR || next->type == TokenType::IDENTIFIER)
                            && resolution != nullptr)
                    {
                        mut TypeSpecifier* type = type_specifier_parse(parser);
                        type->resolution = resolution;

                        scope_add_stmt(scope, var_decl_or_def_parse(parser, type, false));
                    }
                    else
                    {
                        ExprStmt* expr_stmt = expr_stmt_parse(parser);
                        Expr* expr = expr_stmt->expr;

                        switch(expr->type)
                        {
                            case ExprType::FUNC_CALL:
                                {
                                    mut FuncCall* func_call = expr->func_call;
                                    func_call->resolution = resolution;

                                    break;
                                }
                            case ExprType::UNRESOLVED_IDENTIFIER:
                                {
                                    mut UnresolvedIdentifier* unresolved_identifier =
                                        expr->unresolved_identifier;

                                    unresolved_identifier->resolution = resolution;

                                    break;
                                }
                        }

                        scope_add_stmt(scope, stmt_from_expr_stmt(&parser->arena, expr_stmt));
                    }

                    break;
                }
            case TokenType::KW_MUT:
                {
                    parser_eat(parser, TokenType::KW_MUT);

                    TypeSpecifier* type = type_specifier_parse(parser);
                    scope_add_stmt(scope, var_decl_or_def_parse(parser, type, true));

                    break;
                }
            default:
                {
                    scope_add_stmt(scope, stmt_from_expr_stmt(&parser->arena, expr_stmt_parse(parser)));

                    break;
                }
        }
    }

    scope->range.start = start;
    scope->range.end = parser_current_location(parser);

    parser_eat(parser, TokenType::RBRACE);

    while(pushed_scopes > 0)
    {
        parser_pop_scope(parser);
        pushed_scopes = pushed_scopes - 1;
    }

    return scope;
}
