export struct ASTScope
{
    List stmts;
}

export ASTScope* make_scope(Arena* arena)
{
    ASTScope* scope = arena_alloc(arena, sizeof(ASTScope));

    list_init(&scope->stmts);

    return scope;
}

export ASTScope* parse_scope(Parser* parser)
{
    assert(parser != nullptr);

    parser_eat(parser, TOKEN_TYPE_LBRACE);

    parser_push_scope(parser);

    ASTScope* scope = make_scope(&parser->arena);

    while(parser->token->type != TOKEN_TYPE_RBRACE)
    {
        switch(parser->token->type)
        {
            case TOKEN_TYPE_LBRACE:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_SCOPE, parse_scope(parser)));

                break;
            }
            case TOKEN_TYPE_KW_BREAK:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_BREAK_STMT, parse_break_stmt(parser)));

                break;
            }
            case TOKEN_TYPE_KW_CONTINUE:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_CONTINUE_STMT, parse_continue_stmt(parser)));

                break;
            }
            case TOKEN_TYPE_KW_RETURN:
            {
                list_push(&scope->stmts, make_ast(&parser->arena,
                    AST_TYPE_RETURN_STMT, parse_return_stmt(parser)));

                break;
            }
            case TOKEN_TYPE_KW_U8:
            {

            }
            case TOKEN_TYPE_KW_U16:
            {

            }
            case TOKEN_TYPE_KW_U32:
            {

            }
            case TOKEN_TYPE_KW_U64:
            {

            }
            case TOKEN_TYPE_KW_USIZE:
            {

            }
            case TOKEN_TYPE_KW_I8:
            {

            }
            case TOKEN_TYPE_KW_I16:
            {

            }
            case TOKEN_TYPE_KW_I32:
            {

            }
            case TOKEN_TYPE_KW_I64:
            {

            }
            case TOKEN_TYPE_KW_ISIZE:
            {

            }
            case TOKEN_TYPE_KW_B8:
            {

            }
            case TOKEN_TYPE_KW_B16:
            {

            }
            case TOKEN_TYPE_KW_B32:
            {

            }
            case TOKEN_TYPE_KW_B64:
            {

            }
            case TOKEN_TYPE_KW_CHAR:
            {

            }
            case TOKEN_TYPE_KW_F32:
            {

            }
            case TOKEN_TYPE_KW_F64:
            {

            }
            case TOKEN_TYPE_KW_VOID:
            {

            }
            case TOKEN_TYPE_IDENTIFIER:
            {
                ASTTypeSpecifier* type = parse_type_specifier(parser);

                Token* next = parser_peek(parser, 1);
                switch(next->type)
                {
                    case TOKEN_TYPE_SEMICOLON:
                    {
                        list_push(&scope->stmts, make_ast(&parser->arena,
                            AST_TYPE_VAR_DECL, parse_var_decl(parser, type, false)));

                        break;
                    }
                    case TOKEN_TYPE_EQ:
                    {
                        list_push(&scope->stmts, make_ast(&parser->arena,
                            AST_TYPE_VAR_DEF, parse_var_def(parser, type, false)));

                        break;
                    }
                    default:
                    {
                        parser_panic(parser);

                        break;
                    }
                }

                break;
            }
            case TOKEN_TYPE_KW_MUT:
            {
                parser_eat(parser, TOKEN_TYPE_KW_MUT);

                ASTTypeSpecifier* type = parse_type_specifier(parser);

                Token* next = parser_peek(parser, 1);
                if(next->type == TOKEN_TYPE_SEMICOLON)
                {
                    list_push(&scope->stmts, make_ast(&parser->arena,
                        AST_TYPE_VAR_DECL, parse_var_decl(parser, type, true)));
                }
                else
                {
                    list_push(&scope->stmts, make_ast(&parser->arena,
                        AST_TYPE_VAR_DEF, parse_var_def(parser, type, true)));
                }

                break;
            }
            default:
            {
                parser_panic(parser);

                break;
            }
        }
    }

    parser_eat(parser, TOKEN_TYPE_RBRACE);

    parser_pop_scope(parser);

    return scope;
}

export void print_scope(ASTScope* scope, FILE* file, usize depth)
{
    assert(scope != nullptr);

    assert(file != nullptr);

    print_ast_depth(file, depth);

    fprintf(file, "%s\n", ast_type_to_str(AST_TYPE_SCOPE));

    usize i;
    for(i = 0; i < list_size(&scope->stmts); i = i + 1)
    {
        AST* stmt = list_get(&scope->stmts, i);
        print_ast(stmt, file, depth + 1);
    }
}
