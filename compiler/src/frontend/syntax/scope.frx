import "std/libc.frx";
export import "../ast/scope.frx";
import "../ast/expr.frx";
import "break_stmt.frx";
import "continue_stmt.frx";
import "do_while_loop.frx";
import "expr.frx";
import "expr_stmt.frx";
import "for_loop.frx";
import "func_call.frx";
import "if_stmt.frx";
import "namespace_resolution.frx";
import "return_stmt.frx";
import "switch_stmt.frx";
import "type_specifier.frx";
import "unresolved_namespaced_name.frx";
import "var_decl.frx";
import "var_decl_or_def.frx";
import "var_def.frx";
import "while_loop.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../../core/list.frx";

namespace AST::Scope
{
    export Scope* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        SourceLocation start = parser_current_location(parser);

        parser_eat(parser, TokenType::LBRACE);

        parser_push_scope(parser);

        mut usize pushed_scopes = 1;

        mut Scope* scope = new(&parser->arena);

        while(parser_loop_until(parser, TokenType::RBRACE))
        {
            switch(parser->token->type)
            {
                case TokenType::LBRACE:
                {
                    add_stmt(scope, AST::Stmt::from_scope(&parser->arena, parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
                case TokenType::KW_BREAK:
                {
                    add_stmt(scope, AST::Stmt::from_break_stmt(&parser->arena, AST::BreakStmt::parse(parser)));

                    break;
                }
                case TokenType::KW_CONTINUE:
                {
                    add_stmt(scope, AST::Stmt::from_continue_stmt(&parser->arena, AST::ContinueStmt::parse(parser)));

                    break;
                }
                case TokenType::KW_RETURN:
                {
                    add_stmt(scope, AST::Stmt::from_return_stmt(&parser->arena, AST::ReturnStmt::parse(parser)));

                    break;
                }
                case TokenType::KW_IF:
                {
                    add_stmt(scope, AST::Stmt::from_if_stmt(&parser->arena, AST::IfStmt::parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
                case TokenType::KW_FOR:
                {
                    add_stmt(scope, AST::Stmt::from_for_loop(&parser->arena, AST::ForLoop::parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
                case TokenType::KW_WHILE:
                {
                    add_stmt(scope, AST::Stmt::from_while_loop(&parser->arena, AST::WhileLoop::parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
                case TokenType::KW_DO:
                {
                    add_stmt(scope, AST::Stmt::from_do_while_loop(&parser->arena, AST::DoWhileLoop::parse(parser)));

                    parser_push_scope(parser);
                    pushed_scopes = pushed_scopes + 1;

                    break;
                }
                case TokenType::KW_SWITCH:
                {
                    add_stmt(scope, AST::Stmt::from_switch_stmt(&parser->arena, AST::SwitchStmt::parse(parser)));

                    break;
                }
                case TokenType::KW_U8:
                {

                }
                case TokenType::KW_U16:
                {

                }
                case TokenType::KW_U32:
                {

                }
                case TokenType::KW_U64:
                {

                }
                case TokenType::KW_USIZE:
                {

                }
                case TokenType::KW_I8:
                {

                }
                case TokenType::KW_I16:
                {

                }
                case TokenType::KW_I32:
                {

                }
                case TokenType::KW_I64:
                {

                }
                case TokenType::KW_ISIZE:
                {

                }
                case TokenType::KW_B8:
                {

                }
                case TokenType::KW_B16:
                {

                }
                case TokenType::KW_B32:
                {

                }
                case TokenType::KW_B64:
                {

                }
                case TokenType::KW_CHAR:
                {

                }
                case TokenType::KW_F32:
                {

                }
                case TokenType::KW_F64:
                {

                }
                case TokenType::KW_VOID:
                {
                    TypeSpecifier* type = AST::TypeSpecifier::parse(parser);
                    add_stmt(scope, AST::VarDeclOrDef::parse(parser, type, false));

                    break;
                }
                case TokenType::IDENTIFIER:
                {
                    mut Namespace* resolved_ns = nullptr;

                    if(parser->token->type != TokenType::IDENTIFIER ||
                        libc::strcmp(parser->token->identifier, "frx") != 0)
                    {
                        resolved_ns = AST::NamespaceResolution::parse(parser);
                    }

                    Token* next = parser_peek(parser, 1);
                    if(next->type == TokenType::STAR
                        || next->type == TokenType::IDENTIFIER)
                    {
                        mut TypeSpecifier* type = AST::TypeSpecifier::parse(parser);
                        type->ns = resolved_ns;

                        add_stmt(scope, AST::VarDeclOrDef::parse(parser, type, false));
                    }
                    else
                    {
                        ExprStmt* expr_stmt = AST::ExprStmt::parse(parser);
                        Expr* expr = expr_stmt->expr;

                        switch(expr->type)
                        {
                            case AST::ExprType::FUNC_CALL:
                            {
                                mut FuncCall* func_call = expr->func_call;
                                func_call->ns = resolved_ns;

                                break;
                            }
                            case AST::ExprType::UNRESOLVED_NAMESPACED_NAME:
                            {
                                mut UnresolvedNamespacedName* unresolved_namespaced_name =
                                    expr->unresolved_namespaced_name;

                                unresolved_namespaced_name->ns = resolved_ns;

                                break;
                            }
                        }

                        add_stmt(scope, AST::Stmt::from_expr_stmt(&parser->arena, expr_stmt));
                    }

                    break;
                }
                case TokenType::KW_MUT:
                {
                    parser_eat(parser, TokenType::KW_MUT);

                    TypeSpecifier* type = AST::TypeSpecifier::parse(parser);
                    add_stmt(scope, AST::VarDeclOrDef::parse(parser, type, true));

                    break;
                }
                default:
                {
                    add_stmt(scope, AST::Stmt::from_expr_stmt(&parser->arena, AST::ExprStmt::parse(parser)));

                    break;
                }
            }
        }

        scope->range.start = start;
        scope->range.end = parser_current_location(parser);

        parser_eat(parser, TokenType::RBRACE);

        while(pushed_scopes > 0)
        {
            parser_pop_scope(parser);
            pushed_scopes = pushed_scopes - 1;
        }

        return scope;
    }
}
