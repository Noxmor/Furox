export import "../ast/struct_def.frx";
import "type_specifier.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../symbols/struct.frx";
import "../../core/list.frx";

namespace AST::StructField
{
    StructField* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        TypeSpecifier* type = AST::TypeSpecifier::parse(parser);

        char* name = parser->token->identifier;

        Parser::eat(parser, TokenType::IDENTIFIER);
        AST::TypeSpecifier::parse_array_dimensions(parser, type);
        Parser::eat(parser, TokenType::SEMICOLON);

        return new(&parser->arena, type, name);
    }
}

namespace AST::StructDef
{
    export StructDef* parse(Parser* parser, b8 exported)
    {
        frx::assert(parser != nullptr);

        SourceLocation start = Parser::current_location(parser);

        Parser::eat(parser, TokenType::KW_STRUCT);

        char* name = parser->token->identifier;

        mut StructDef* struct_def = new(&parser->arena, parser->current_scope,
            parser->current_namespace, name, exported);

        struct_def->is_redefinition = !struct_table_insert(&parser->struct_table,
            &struct_def->symbol);

        Parser::eat(parser, TokenType::IDENTIFIER);

        Parser::eat(parser, TokenType::LBRACE);

        while(Parser::loop_until(parser, TokenType::RBRACE))
        {
            list_push(&struct_def->symbol.fields, AST::StructField::parse(parser));
        }

        struct_def->range.start = start;
        struct_def->range.end = Parser::current_location(parser);

        Parser::eat(parser, TokenType::RBRACE);

        return struct_def;
    }
}
