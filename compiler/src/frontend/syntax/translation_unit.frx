ASTCompound* parse_translation_unit(Parser* parser)
{
    ASTCompound* translation_unit = make_compound(&parser->arena);

    while(parser->token->type != TOKEN_TYPE_EOF
        && parser->token->type != TOKEN_TYPE_ERROR)
    {
        AST* ast = nullptr;

        switch(parser->token->type)
        {
            case TOKEN_TYPE_KW_IMPORT:
            {
                ast = make_ast(&parser->arena, AST_TYPE_IMPORT_STMT,
                    parse_import_stmt(parser));

                break;
            }
            case TOKEN_TYPE_KW_NAMESPACE:
            {
                ast = make_ast(&parser->arena, AST_TYPE_NAMESPACE,
                    parse_namespace(parser));

                break;
            }
            case TOKEN_TYPE_KW_ENUM:
            {
                ast = make_ast(&parser->arena, AST_TYPE_ENUM_DEF,
                    parse_enum_def(parser, false));

                break;
            }
            case TOKEN_TYPE_KW_STRUCT:
            {
                ast = make_ast(&parser->arena, AST_TYPE_STRUCT_DEF,
                    parse_struct_def(parser, false));

                break;
            }
            case TOKEN_TYPE_KW_EXTERN:
            {
                Token* next = parser_peek(parser, 1);
                if(next->type == TOKEN_TYPE_LBRACE)
                {
                    ast = make_ast(&parser->arena, AST_TYPE_EXTERN_BLOCK,
                        parse_extern_block(parser));
                }
                else
                {
                    parser_eat(parser, TOKEN_TYPE_KW_EXTERN);

                    ast = make_ast(&parser->arena, AST_TYPE_FUNC_DECL,
                        parse_func_decl(parser));
                }

                break;
            }
            case TOKEN_TYPE_KW_EXPORT:
            {
                parser_eat(parser, TOKEN_TYPE_KW_EXPORT);

                switch(parser->token->type)
                {
                    case TOKEN_TYPE_KW_ENUM:
                    {
                        ast = make_ast(&parser->arena, AST_TYPE_ENUM_DEF,
                            parse_enum_def(parser, true));

                        break;
                    }
                    case TOKEN_TYPE_KW_STRUCT:
                    {
                        ast = make_ast(&parser->arena, AST_TYPE_STRUCT_DEF,
                            parse_struct_def(parser, true));

                        break;
                    }
                    default:
                    {
                        ASTTypeSpecifier* type_specifier =
                            parse_type_specifier(parser);
                        ast = make_ast(&parser->arena, AST_TYPE_FUNC_DEF,
                            parse_func_def(parser, type_specifier, true));

                        break;
                    }
                }

                break;
            }
            case TOKEN_TYPE_KW_U8:
            {

            }
            case TOKEN_TYPE_KW_U16:
            {

            }
            case TOKEN_TYPE_KW_U32:
            {

            }
            case TOKEN_TYPE_KW_U64:
            {

            }
            case TOKEN_TYPE_KW_USIZE:
            {

            }
            case TOKEN_TYPE_KW_I8:
            {

            }
            case TOKEN_TYPE_KW_I16:
            {

            }
            case TOKEN_TYPE_KW_I32:
            {

            }
            case TOKEN_TYPE_KW_I64:
            {

            }
            case TOKEN_TYPE_KW_ISIZE:
            {

            }
            case TOKEN_TYPE_KW_B8:
            {

            }
            case TOKEN_TYPE_KW_B16:
            {

            }
            case TOKEN_TYPE_KW_B32:
            {

            }
            case TOKEN_TYPE_KW_B64:
            {

            }
            case TOKEN_TYPE_KW_CHAR:
            {

            }
            case TOKEN_TYPE_KW_F32:
            {

            }
            case TOKEN_TYPE_KW_F64:
            {

            }
            case TOKEN_TYPE_KW_VOID:
            {

            }
            case TOKEN_TYPE_IDENTIFIER:
            {
                ASTTypeSpecifier* type_specifier = parse_type_specifier(parser);

                Token* next = parser_peek(parser, 1);
                switch(next->type)
                {
                    case TOKEN_TYPE_SEMICOLON:
                    {
                        ast = make_ast(&parser->arena, AST_TYPE_GLOBAL_VAR_DECL,
                            parse_global_var_decl(parser, type_specifier,
                            false));

                        break;
                    }
                    case TOKEN_TYPE_EQ:
                    {
                        ast = make_ast(&parser->arena, AST_TYPE_GLOBAL_VAR_DEF,
                            parse_global_var_def(parser, type_specifier,
                            false));

                        break;
                    }
                    case TOKEN_TYPE_LPAREN:
                    {
                        ast = make_ast(&parser->arena, AST_TYPE_FUNC_DEF,
                            parse_func_def(parser, type_specifier, false));

                        break;
                    }
                    default:
                    {
                        parser_panic(parser);

                        break;
                    }
                }

                break;
            }
            case TOKEN_TYPE_KW_MUT:
            {
                parser_eat(parser, TOKEN_TYPE_KW_MUT);

                ASTTypeSpecifier* type_specifier = parse_type_specifier(parser);

                Token* next = parser_peek(parser, 1);
                if(next->type == TOKEN_TYPE_SEMICOLON)
                {
                    ast = make_ast(&parser->arena, AST_TYPE_GLOBAL_VAR_DECL,
                        parse_global_var_decl(parser, type_specifier, true));
                }
                else
                {
                    ast = make_ast(&parser->arena, AST_TYPE_GLOBAL_VAR_DEF,
                        parse_global_var_def(parser, type_specifier, true));
                }

                break;
            }
            default:
            {
                parser_panic(parser);

                break;
            }
        }

        if(ast != nullptr)
        {
            list_push(&translation_unit->nodes, ast);
        }
    }

    return translation_unit;
}
