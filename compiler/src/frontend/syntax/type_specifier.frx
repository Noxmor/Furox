export struct ASTTypeSpecifier
{
    TokenType primitive_type;
    ASTEnumDef* enum_type;
    ASTStructDef* struct_type;

    usize pointer_level;

    List array_dimensions;
}

export ASTTypeSpecifier* make_type_specifier(Arena* arena,
    TokenType primitive_type, ASTEnumDef* enum_type, ASTStructDef* struct_type,
    usize pointer_level)
{
    ASTTypeSpecifier* type_specifier = arena_alloc(arena,
        sizeof(ASTTypeSpecifier));

    type_specifier->primitive_type = primitive_type;
    type_specifier->enum_type = enum_type;
    type_specifier->struct_type = struct_type;
    type_specifier->pointer_level = pointer_level;
    list_init(&type_specifier->array_dimensions);

    return type_specifier;
}

export ASTTypeSpecifier* parse_type_specifier(Parser* parser)
{
    assert(parser != nullptr);

    TokenType primitive_type = TOKEN_TYPE_ERROR;
    ASTEnumDef* enum_type = nullptr;
    ASTStructDef* struct_type = nullptr;

    if(token_type_is_primitive(parser->token->type))
    {
        primitive_type = parser->token->type;

        parser_eat(parser, parser->token->type);
    }
    else
    {
        Token* next = parser_peek(parser, 1);

        Namespace* type_namespace = parser->current_namespace;
        if(next->type == TOKEN_TYPE_NAMESPACE_RESOLUTION)
        {
            type_namespace = nullptr;
        }

        while(next->type == TOKEN_TYPE_NAMESPACE_RESOLUTION)
        {
            type_namespace = namespace_create(type_namespace,
                parser->token->identifier);

            parser_eat(parser, TOKEN_TYPE_IDENTIFIER);
            parser_eat(parser, TOKEN_TYPE_NAMESPACE_RESOLUTION);

            next = parser_peek(parser, 1);
        }

        if(type_namespace == parser->current_namespace)
        {
            while(true)
            {
                enum_type = enum_table_find(type_namespace, parser->token->identifier);
                struct_type = struct_table_find(type_namespace,
                    parser->token->identifier);

                if(enum_type != nullptr || struct_type != nullptr
                    || type_namespace == nullptr)
                {
                    break;
                }

                type_namespace = type_namespace->parent;
            }
        }
        else
        {
            enum_type = enum_table_find(type_namespace, parser->token->identifier);
            struct_type = struct_table_find(type_namespace,
                parser->token->identifier);
        }

        //TODO: This manual cleanup is certainly not the best solution.
        while(type_namespace != nullptr && type_namespace != parser->current_namespace)
        {
            Namespace* free_ns = type_namespace;
            type_namespace = type_namespace->parent;
            free(type_namespace);
        }

        parser_eat(parser, TOKEN_TYPE_IDENTIFIER);
    }

    usize pointer_level = 0;

    while(parser->token->type == TOKEN_TYPE_STAR)
    {
        pointer_level = pointer_level + 1;

        parser_eat(parser, TOKEN_TYPE_STAR);
    }

    ASTTypeSpecifier* type_specifier = make_type_specifier(&parser->arena,
        primitive_type, enum_type, struct_type, pointer_level);

    while(parser->token->type == TOKEN_TYPE_LBRACKET)
    {
        parser_eat(parser, TOKEN_TYPE_LBRACKET);

        list_push(&type_specifier->array_dimensions, parse_expr(parser));

        parser_eat(parser, TOKEN_TYPE_RBRACKET);
    }

    return type_specifier;
}

void print_type_specifier(ASTTypeSpecifier* type_specifier, FILE* file,
    usize depth)
{
    assert(type_specifier != nullptr);

    assert(file != nullptr);

    print_ast_depth(file, depth);

    fprintf(file, "%s\n", ast_type_to_str(AST_TYPE_TYPE_SPECIFIER));

    print_ast_depth(file, depth + 1);

    fprintf(file, "type: ");
    if(type_specifier->primitive_type != 0)
    {
        fprintf(file, "%s", token_type_to_str(type_specifier->primitive_type));
    }
    else if(type_specifier->enum_type != nullptr)
    {
        ASTEnumDef* enum_def = type_specifier->enum_type;

        print_namespace_resolution(file, enum_def->ns);
        fprintf(file, "%s", enum_def->name);
    }
    else if(type_specifier->struct_type != nullptr)
    {
        ASTStructDef* struct_def = type_specifier->struct_type;

        print_namespace_resolution(file, struct_def->ns);
        fprintf(file, "%s", struct_def->name);
    }

    fprintf(file, "\n");

    print_ast_depth(file, depth + 1);

    fprintf(file, "pointer_level: %zu\n", type_specifier->pointer_level);

    print_ast_depth(file, depth + 1);

    fprintf(file, "array-dimensions\n");

    usize i;
    for(i = 0; i < list_size(&type_specifier->array_dimensions); i = i + 1)
    {
        print_ast(list_get(&type_specifier->array_dimensions, i), file,
            depth + 2);
    }
}
