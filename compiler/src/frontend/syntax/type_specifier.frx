export import "../ast/type_specifier.frx";
import "expr.frx";
import "namespace_resolution.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../core/source_range.frx";
import "../symbols/enum.frx";
import "../symbols/struct.frx";
import "../../core/list.frx";

namespace AST::TypeSpecifier
{
    export void parse_array_dimensions(Parser* parser, TypeSpecifier* type)
    {
        frx::assert(parser != nullptr);

        frx::assert(type != nullptr);

        while(parser->token->type == TokenType::LBRACKET)
        {
            Parser::eat(parser, TokenType::LBRACKET);
            List::push(&type->array_dimensions, AST::Expr::parse(parser));
            Parser::eat(parser, TokenType::RBRACKET);
        }
    }
}

namespace AST::TypeSpecifier
{
    export TypeSpecifier* parse(Parser* parser)
    {
        frx::assert(parser != nullptr);

        SourceLocation start = Parser::current_location(parser);

        NamespaceResolution* resolution = AST::NamespaceResolution::parse(parser);
        mut char* name = nullptr;
        mut TokenType primitive_type = TokenType::EOF;

        if(TokenType::is_primitive(parser->token->type))
        {
            primitive_type = parser->token->type;

            Parser::eat(parser, parser->token->type);
        }
        else
        {
            name = parser->token->identifier;

            Parser::eat(parser, TokenType::IDENTIFIER);
        }

        mut usize pointer_level = 0;

        mut SourceLocation end;

        while(parser->token->type == TokenType::STAR)
        {
            pointer_level = pointer_level + 1;

            end = Parser::current_location(parser);

            Parser::eat(parser, TokenType::STAR);
        }

        mut TypeSpecifier* type_specifier = new(&parser->arena, resolution, name,
            parser->current_scope, primitive_type, pointer_level);

        type_specifier->range.start = start;
        type_specifier->range.end = end;

        return type_specifier;
    }
}
