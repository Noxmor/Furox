export import "../ast/type_specifier.frx";
import "expr.frx";
import "namespace_resolution.frx";
import "../core/namespace.frx";
import "../core/parser.frx";
import "../core/scope.frx";
import "../core/source_range.frx";
import "../symbols/enum.frx";
import "../symbols/struct.frx";
import "../../core/list.frx";

export void type_specifier_parse_array_dimensions(Parser* parser, TypeSpecifier* type)
{
    frx::assert(parser != nullptr);

    frx::assert(type != nullptr);

    while(parser->token->type == TokenType::LBRACKET)
    {
        parser_eat(parser, TokenType::LBRACKET);
        list_push(&type->array_dimensions, expr_parse(parser));
        parser_eat(parser, TokenType::RBRACKET);
    }
}

export TypeSpecifier* type_specifier_parse(Parser* parser)
{
    frx::assert(parser != nullptr);

    SourceLocation start = parser_current_location(parser);

    NamespaceResolution* resolution = namespace_resolution_parse(parser);
    mut char* name = nullptr;
    mut TokenType primitive_type = TokenType::EOF;

    if(token_type_is_primitive(parser->token->type))
    {
        primitive_type = parser->token->type;

        parser_eat(parser, parser->token->type);
    }
    else
    {
        name = parser->token->identifier;

        parser_eat(parser, TokenType::IDENTIFIER);
    }

    mut usize pointer_level = 0;

    mut SourceLocation end;

    while(parser->token->type == TokenType::STAR)
    {
        pointer_level = pointer_level + 1;

        end = parser_current_location(parser);

        parser_eat(parser, TokenType::STAR);
    }

    mut TypeSpecifier* type_specifier = type_specifier_new(&parser->arena, resolution, name,
            parser->current_scope, primitive_type, pointer_level);

    type_specifier->range.start = start;
    type_specifier->range.end = end;

    return type_specifier;
}
