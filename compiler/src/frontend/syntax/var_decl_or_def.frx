export import "../ast/stmt.frx";
import "type_specifier.frx";
import "var_decl.frx";
import "var_def.frx";
import "../core/parser.frx";

namespace AST::VarDeclOrDef
{
    export Stmt* parse(Parser* parser, TypeSpecifier* type, b8 mutable)
    {
        frx::assert(parser != nullptr);

        frx::assert(type != nullptr);

        char* name = parser->token->identifier;

        Parser::eat(parser, TokenType::IDENTIFIER);

        AST::TypeSpecifier::parse_array_dimensions(parser, type);

        mut Stmt* stmt = nullptr;

        switch(parser->token->type)
        {
            case TokenType::SEMICOLON:
            {
                stmt = AST::Stmt::from_var_decl(&parser->arena,
                    AST::VarDecl::parse(parser, type, name, mutable));

                break;
            }
            case TokenType::EQ:
            {
                stmt = AST::Stmt::from_var_def(&parser->arena,
                    AST::VarDef::parse(parser, type, name, mutable));

                break;
            }
            default:
            {
                Parser::panic(parser);

                break;
            }
        }

        return stmt;
    }
}
