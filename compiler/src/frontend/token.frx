//TODO: Replace with C-like direct indexing: [TOKEN_TYPE] = "string" to be indepentent of the order of declaration in the enum
char*[TOKEN_TYPE_COUNT] token_type_names = {
    "error",
    "eof",

    "identifier",
    "int-literal",
    "float-literal",

    "u8",
    "u16",
    "u32",
    "u64",
    "usize",
    "i8",
    "i16",
    "i32",
    "i64",
    "isize",
    "b8",
    "b16",
    "b32",
    "b64",
    "char",
    "f32",
    "f64",
    "void",

    "nullptr",
    "true",
    "false",
    "import",
    "export",
    "mut",
    "return",
    "namespace",
    "extern",
    "struct",
    "enum",
    "if",
    "else",
    "switch",
    "case",
    "default",
    "break",
    "continue",
    "for",
    "while",
    "do",
    "defer",
    "macro",

    "char-literal",
    "string-literal",

    "+",
    "+=",

    "-",
    "-=",

    "*",
    "*=",

    "/",
    "/=",

    "%",
    "%=",

    "&&",
    "||",
    "!",

    "&",
    "&=",

    "|",
    "|=",

    "^",
    "^=",

    "~",
    "~=",

    "<<",
    "<<=",

    ">>",
    ">>=",

    "=",
    "!=",
    "==",

    ">",
    ">=",

    "<",
    "<=",

    "(",
    ")",

    "[",
    "]",

    "{",
    "}",

    "->",
    ".",
    ",",
    ":",
    ";",

    "...",

    "::"
};

export enum TokenType : u8
{
    TOKEN_TYPE_ERROR = 0,
    TOKEN_TYPE_EOF,

    TOKEN_TYPE_IDENTIFIER,
    TOKEN_TYPE_INT_LITERAL,
    TOKEN_TYPE_FLOAT_LITERAL,

    TOKEN_TYPE_KW_U8,
    TOKEN_TYPE_KW_U16,
    TOKEN_TYPE_KW_U32,
    TOKEN_TYPE_KW_U64,
    TOKEN_TYPE_KW_USIZE,
    TOKEN_TYPE_KW_I8,
    TOKEN_TYPE_KW_I16,
    TOKEN_TYPE_KW_I32,
    TOKEN_TYPE_KW_I64,
    TOKEN_TYPE_KW_ISIZE,
    TOKEN_TYPE_KW_B8,
    TOKEN_TYPE_KW_B16,
    TOKEN_TYPE_KW_B32,
    TOKEN_TYPE_KW_B64,
    TOKEN_TYPE_KW_CHAR,
    TOKEN_TYPE_KW_F32,
    TOKEN_TYPE_KW_F64,
    TOKEN_TYPE_KW_VOID,

    TOKEN_TYPE_KW_NULLPTR,
    TOKEN_TYPE_KW_TRUE,
    TOKEN_TYPE_KW_FALSE,
    TOKEN_TYPE_KW_IMPORT,
    TOKEN_TYPE_KW_EXPORT,
    TOKEN_TYPE_KW_MUT,
    TOKEN_TYPE_KW_RETURN,
    TOKEN_TYPE_KW_NAMESPACE,
    TOKEN_TYPE_KW_EXTERN,
    TOKEN_TYPE_KW_STRUCT,
    TOKEN_TYPE_KW_ENUM,
    TOKEN_TYPE_KW_IF,
    TOKEN_TYPE_KW_ELSE,
    TOKEN_TYPE_KW_SWITCH,
    TOKEN_TYPE_KW_CASE,
    TOKEN_TYPE_KW_DEFAULT,
    TOKEN_TYPE_KW_BREAK,
    TOKEN_TYPE_KW_CONTINUE,
    TOKEN_TYPE_KW_FOR,
    TOKEN_TYPE_KW_WHILE,
    TOKEN_TYPE_KW_DO,
    TOKEN_TYPE_KW_DEFER,
    TOKEN_TYPE_KW_MACRO,

    TOKEN_TYPE_CHAR_LITERAL,
    TOKEN_TYPE_STRING_LITERAL,

    TOKEN_TYPE_PLUS,
    TOKEN_TYPE_PLUS_EQ,

    TOKEN_TYPE_MINUS,
    TOKEN_TYPE_MINUS_EQ,

    TOKEN_TYPE_STAR,
    TOKEN_TYPE_MULTIPLY_EQ,

    TOKEN_TYPE_DIVIDE,
    TOKEN_TYPE_DIVIDE_EQ,

    TOKEN_TYPE_MODULO,
    TOKEN_TYPE_MODULO_EQ,

    TOKEN_TYPE_LOG_AND,
    TOKEN_TYPE_LOG_OR,
    TOKEN_TYPE_LOG_NEG,

    TOKEN_TYPE_BIN_AND,
    TOKEN_TYPE_BIN_AND_EQ,

    TOKEN_TYPE_BIN_OR,
    TOKEN_TYPE_BIN_OR_EQ,

    TOKEN_TYPE_BIN_XOR,
    TOKEN_TYPE_BIN_XOR_EQ,

    TOKEN_TYPE_BIN_NEG,
    TOKEN_TYPE_BIN_NEG_EQ,

    TOKEN_TYPE_BIN_LSHIFT,
    TOKEN_TYPE_BIN_LSHIFT_EQ,

    TOKEN_TYPE_BIN_RSHIFT,
    TOKEN_TYPE_BIN_RSHIFT_EQ,

    TOKEN_TYPE_EQ,
    TOKEN_TYPE_LOG_NEQ,
    TOKEN_TYPE_LOG_EQ,

    TOKEN_TYPE_GT,
    TOKEN_TYPE_GEQ,

    TOKEN_TYPE_LT,
    TOKEN_TYPE_LEQ,

    TOKEN_TYPE_LPAREN,
    TOKEN_TYPE_RPAREN,

    TOKEN_TYPE_LBRACKET,
    TOKEN_TYPE_RBRACKET,

    TOKEN_TYPE_LBRACE,
    TOKEN_TYPE_RBRACE,

    TOKEN_TYPE_ARROW,
    TOKEN_TYPE_DOT,
    TOKEN_TYPE_COMMA,
    TOKEN_TYPE_COLON,
    TOKEN_TYPE_SEMICOLON,

    TOKEN_TYPE_ELLIPSIS,

    TOKEN_TYPE_NAMESPACE_RESOLUTION,

    TOKEN_TYPE_COUNT
}

export b8 token_type_is_primitive(TokenType type)
{
    assert(type < TOKEN_TYPE_COUNT);

    return type >= TOKEN_TYPE_KW_U8 && type <= TOKEN_TYPE_KW_VOID;
}

export b8 token_type_is_unary_operator(TokenType type)
{
    assert(type < TOKEN_TYPE_COUNT);

    switch(type)
    {
        case TOKEN_TYPE_BIN_AND:
        {

        }
        case TOKEN_TYPE_MINUS:
        {

        }
        case TOKEN_TYPE_LOG_NEG:
        {

        }
        case TOKEN_TYPE_BIN_NEG:
        {
            return true;
        }
    }

    return false;
}

export b8 token_type_is_binary_operator(TokenType type)
{
    assert(type < TOKEN_TYPE_COUNT);

    switch(type)
    {
        case TOKEN_TYPE_PLUS:
        {

        }
        case TOKEN_TYPE_PLUS_EQ:
        {

        }
        case TOKEN_TYPE_MINUS:
        {

        }
        case TOKEN_TYPE_MINUS_EQ:
        {

        }
        case TOKEN_TYPE_STAR:
        {

        }
        case TOKEN_TYPE_STAR_EQ:
        {

        }
        case TOKEN_TYPE_DIVIDE:
        {

        }
        case TOKEN_TYPE_DIVIDE_EQ:
        {

        }
        case TOKEN_TYPE_MODULO:
        {

        }
        case TOKEN_TYPE_MODULO_EQ:
        {

        }
        case TOKEN_TYPE_LOG_AND:
        {

        }
        case TOKEN_TYPE_LOG_OR:
        {

        }
        case TOKEN_TYPE_BIN_AND:
        {

        }
        case TOKEN_TYPE_BIN_AND_EQ:
        {

        }
        case TOKEN_TYPE_BIN_OR:
        {

        }
        case TOKEN_TYPE_BIN_OR_EQ:
        {

        }
        case TOKEN_TYPE_BIN_XOR:
        {

        }
        case TOKEN_TYPE_BIN_XOR_EQ:
        {

        }
        case TOKEN_TYPE_BIN_NEG_EQ:
        {

        }
        case TOKEN_TYPE_BIN_LSHIFT:
        {

        }
        case TOKEN_TYPE_BIN_LSHIFT_EQ:
        {

        }
        case TOKEN_TYPE_BIN_RSHIFT:
        {

        }
        case TOKEN_TYPE_BIN_RSHIFT_EQ:
        {

        }
        case TOKEN_TYPE_EQ:
        {

        }
        case TOKEN_TYPE_LOG_NEQ:
        {

        }
        case TOKEN_TYPE_LOG_EQ:
        {

        }
        case TOKEN_TYPE_GT:
        {

        }
        case TOKEN_TYPE_GEQ:
        {

        }
        case TOKEN_TYPE_LT:
        {

        }
        case TOKEN_TYPE_LEQ:
        {
            return true;
        }
    }

    return false;
}

export enum Precedence : u8
{
    PRECEDENCE_MAX,

    PRECEDENCE_1,
    PRECEDENCE_2,
    PRECEDENCE_3,
    PRECEDENCE_4,
    PRECEDENCE_5,
    PRECEDENCE_6,
    PRECEDENCE_7,
    PRECEDENCE_8,
    PRECEDENCE_9,
    PRECEDENCE_10,
    PRECEDENCE_11,
    PRECEDENCE_12,
    PRECEDENCE_13,
    PRECEDENCE_14,

    PRECEDENCE_MIN,

    PRECEDENCE_COUNT
}

export Precedence token_type_to_binary_operator_precedence(TokenType type)
{
    assert(type < TOKEN_TYPE_COUNT);

    switch(type)
    {
        case TOKEN_TYPE_PLUS:
        {
            return PRECEDENCE_4;
        }
        case TOKEN_TYPE_MINUS:
        {
            return PRECEDENCE_4;
        }
        case TOKEN_TYPE_STAR:
        {
            return PRECEDENCE_3;
        }
        case TOKEN_TYPE_DIVIDE:
        {
            return PRECEDENCE_3;
        }
        case TOKEN_TYPE_MODULO:
        {
            return PRECEDENCE_3;
        }
    }

    assert(false);

    return PRECEDENCE_1;
}

export struct SourceLocation
{
    usize pos;
    usize line;
    usize column;
}

export struct SourceRange
{
    SourceLocation start;
    SourceLocation end;
}

export struct Token
{
    TokenType type;

    SourceRange range;

    char* identifier;
    u64 int_literal;
    f64 float_literal;
}

export char* token_type_to_str(TokenType type)
{
    assert(type < TOKEN_TYPE_COUNT);

    return token_type_names[type];
}
